diff --git a/src/core/application.cpp b/src/core/application.cpp
index e951d35..462f4c4 100644
--- a/src/core/application.cpp
+++ b/src/core/application.cpp
@@ -97,14 +97,89 @@ void Application::readEvents(std::ifstream& is, int eventPops)
     is.close();
 }
 
+void Application::drainEventQueue()
+{
+    int i = 0;
+    while (i < dispatcher.eventQueue.size())
+    {
+        auto& event = dispatcher.eventQueue.items[i];
+        if (event)
+        {
+            if (recordevents) recordEvent(event.get(), os);
+
+            for (auto state : stateStack) 
+            {
+                state->handleEvent(event.get());
+                if (event->isHandled()) 
+                    break;
+            }
+
+        }
+
+        if (stateEdits.size() > 0)
+        {
+            int j = 0;
+            while (j < stateEdits.size())
+            {
+                auto state = stateEdits.at(j);
+                if (state)
+                    pushState(state);
+                else
+                    popState();
+                j++;
+            }
+            stateEdits.clear();
+            // this allows mutiple leaves to be pushed at once, and they get entered in order
+            if (stateStack.top()->getType() == state::StateType::leaf)
+                stateStack.top()->onEnter();
+        }
+        i++;
+    }
+    dispatcher.eventQueue.items.clear();
+}
+
+void Application::executeCommands()
+{
+    if (!cmdStack.empty())
+    {
+        cmdStack.reverse();
+    }
+    while (!cmdStack.empty())
+    {
+        auto cmd = cmdStack.topPtr();
+        if (cmd)
+        {
+            cmd->execute(this);
+            std::cout << "Command run: " << cmd->getName() << ", Success status: " << cmd->succeeded() << '\n';
+        }
+        else
+            std::cout << "Recieved null cmd" << std::endl;
+        cmdStack.pop();
+        if (cmd && cmd->succeeded())
+            cmd->onSuccess();
+    }
+    cmdStack.items.clear();
+    std::this_thread::sleep_for(std::chrono::milliseconds(1));
+}
+
+void Application::beginFrame()
+{
+    auto event = beginFramePool.request();
+    dispatcher.eventQueue.push(std::move(event));
+}
+
+void Application::endFrame()
+{
+    auto event = endFramePool.request();
+    dispatcher.eventQueue.push(std::move(event));
+}
+
 void Application::run(bool pollEvents)
 {
     if (pollEvents)
     {
         dispatcher.pollEvents();
     }
-    int i{0};
-    int j{0};
 
     if (readevents)
         is.open(readlog, std::ios::binary);
@@ -114,70 +189,17 @@ void Application::run(bool pollEvents)
     {
         if (!pollEvents)
             keepRunnning = false; //only runs once
-        i = 0;
         if (readevents && eventsRead < maxEventReads)
         {
             dispatcher.readEvent(is);
             eventsRead++;
         }
-        while (i < dispatcher.eventQueue.size())
-        {
-            auto& event = dispatcher.eventQueue.items[i];
-            if (event)
-            {
-                std::cout << "Got event: " << event->getName() << '\n';
-                if (recordevents) recordEvent(event.get(), os);
-                if (event->getCategory() == event::Category::CommandLine)
-                {
-                    auto ce = state::toCommandLine(event.get());
-                    std::cout << ce->getInput() << '\n';
-                }
-
-                for (auto state : stateStack) 
-                    if (!event->isHandled())
-                        state->handleEvent(event.get());
-            }
-            if (stateEdits.size() > 0)
-            {
-                j = 0;
-                while (j < stateEdits.size())
-                {
-                    auto state = stateEdits.at(j);
-                    if (state)
-                        pushState(state);
-                    else
-                        popState();
-                    j++;
-                }
-                stateEdits.clear();
-                // this allows mutiple leaves to be pushed at once, and they get entered in order
-                if (stateStack.top()->getType() == state::StateType::leaf)
-                    stateStack.top()->onEnter();
-            }
-            i++;
-        }
-        dispatcher.eventQueue.items.clear();
-        // see below
-        if (!cmdStack.empty())
-        {
-            cmdStack.reverse();
-        }
-        while (!cmdStack.empty())
-        {
-            auto cmd = cmdStack.topPtr();
-            if (cmd)
-            {
-                cmd->execute(this);
-                std::cout << "Command run: " << cmd->getName() << ", Success status: " << cmd->succeeded() << '\n';
-            }
-            else
-                std::cout << "Recieved null cmd" << std::endl;
-            cmdStack.pop();
-            if (cmd && cmd->succeeded())
-                cmd->onSuccess();
-        }
-        cmdStack.items.clear();
-        std::this_thread::sleep_for(std::chrono::milliseconds(1));
+
+        beginFrame();
+
+        drainEventQueue();
+
+        executeCommands();
     }
     if (readevents)
         is.close();
