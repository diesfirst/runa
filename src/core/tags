!_TAG_FILE_FORMAT	2	/extended format; --format=1 will not append ;" to lines/
!_TAG_FILE_SORTED	1	/0=unsorted, 1=sorted, 2=foldcase/
!_TAG_PROGRAM_AUTHOR	Darren Hiebert	/dhiebert@users.sourceforge.net/
!_TAG_PROGRAM_NAME	Exuberant Ctags	//
!_TAG_PROGRAM_URL	http://ctags.sourceforge.net	/official site/
!_TAG_PROGRAM_VERSION	5.9~svn20110310	//
A	event/event.hpp	/^    A = 38,$/;"	m	class:sword::event::symbol::Key
APPLICATION_HPP_	application.hpp	2;"	d
Abort	event/event.hpp	/^    Abort,$/;"	m	class:sword::event::symbol::Category
Abort	event/event.hpp	/^class Abort : public Event$/;"	c	namespace:sword::event::symbol
AddAttachment	command/rendercommands.hpp	/^class AddAttachment: public Command$/;"	c	namespace:sword::command
AddVocab	command/vocab.hpp	/^class AddVocab : public Command$/;"	c	namespace:sword::command
Alt	event/event.hpp	/^    Alt = 64,$/;"	m	class:sword::event::symbol::Key
Application	application.cpp	/^Application::Application(bool validation) :$/;"	f	class:sword::Application
Application	application.cpp	/^Application::Application(uint16_t w, uint16_t h, const std::string logfile, int event_reads) :$/;"	f	class:sword::Application
Application	application.hpp	/^class Application$/;"	c	namespace:sword
Attachment	render/attachment.cpp	/^Attachment::Attachment($/;"	f	class:sword::render::Attachment
Attachment	render/attachment.cpp	/^Attachment::Attachment(const vk::Device& device, std::unique_ptr<Image> swapimage) :$/;"	f	class:sword::render::Attachment
Attachment	render/attachment.hpp	/^class Attachment$/;"	c	namespace:sword::render
Attachment	state/report.hpp	/^    Attachment,$/;"	m	class:sword::state::ReportType
AttachmentReport	state/report.hpp	/^    AttachmentReport(const std::string n, const int w, const int h, vk::ImageUsageFlags f) :$/;"	f	class:sword::state::AttachmentReport
AttachmentReport	state/report.hpp	/^class AttachmentReport : public Report$/;"	c	namespace:sword::state
B	event/event.hpp	/^    B = 56,$/;"	m	class:sword::event::symbol::Key
BindUboData	command/rendercommands.hpp	/^class BindUboData : public Command$/;"	c	namespace:sword::command
BranchState	state/state.hpp	/^    BranchState(StateArgs sa, Callbacks cb, std::initializer_list<Element> ops) :$/;"	f	class:sword::state::BranchState
BranchState	state/state.hpp	/^class BranchState : public State$/;"	c	namespace:sword::state
BriefState	state/state.hpp	/^    BriefState(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::BriefState
BriefState	state/state.hpp	/^class BriefState : public LeafState$/;"	c	namespace:sword::state
Buffer	render/resource.cpp	/^Buffer::Buffer($/;"	f	class:sword::render::Buffer
BufferBlock	render/resource.hpp	/^struct BufferBlock$/;"	s	namespace:sword::render
BufferResources	render/types.hpp	/^struct BufferResources$/;"	s	namespace:sword::render
C	event/event.hpp	/^    C = 54,$/;"	m	class:sword::event::symbol::Key
CMD_BASE	command/command.hpp	6;"	d
COMMAND_COMMANDPOOLS_HPP	command/commandpools.hpp	2;"	d
COMMAND_COMMAND_H_	command/command.hpp	2;"	d
COMMAND_SAVEIMAGE_HPP	command/saveimage.hpp	2;"	d
COMMAND_SHADER_HPP	command/shader.hpp	2;"	d
COMMAND_VOCAB_HPP	command/vocab.hpp	2;"	d
COMMAND_WATCHER_HPP	command/watcher.hpp	2;"	d
CONTEXT_H	render/context.hpp	2;"	d
C_HEIGHT	state/painter.hpp	/^constexpr uint32_t C_HEIGHT = 1600;$/;"	m	namespace:sword::state::painter
C_WIDTH	state/painter.hpp	/^constexpr uint32_t C_WIDTH = 1600;$/;"	m	namespace:sword::state::painter
Callbacks	state/state.hpp	/^struct Callbacks$/;"	s	namespace:sword::state
Category	event/event.hpp	/^enum class Category : uint8_t$/;"	c	namespace:sword::event::symbol
Command	command/command.hpp	/^class Command$/;"	c	namespace:sword::command
CommandBuffer	render/command.cpp	/^CommandBuffer::CommandBuffer($/;"	f	class:sword::render::CommandBuffer
CommandBuffer	render/command.hpp	/^class CommandBuffer$/;"	c	namespace:sword::render
CommandLine	event/event.hpp	/^    CommandLine,$/;"	m	class:sword::event::symbol::Category
CommandLine	event/event.hpp	/^    CommandLine,$/;"	m	class:sword::event::symbol::InputMode
CommandLine	event/event.hpp	/^class CommandLine: public Event$/;"	c	namespace:sword::event::symbol
CommandPool	render/command.cpp	/^CommandPool::CommandPool($/;"	f	class:sword::render::CommandPool
CommandPool	render/command.hpp	/^class CommandPool$/;"	c	namespace:sword::render
CommandPools	command/commandpools.hpp	/^struct CommandPools$/;"	s	namespace:sword
CompileShader	command/shader.cpp	/^CompileShader::CompileShader()$/;"	f	class:sword::command::CompileShader
CompileShader	command/shader.hpp	/^class CompileShader : public Command$/;"	c	namespace:sword::command
CompileShader	state/shader.cpp	/^CompileShader::CompileShader(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::CompileShader
CompileShader	state/shader.hpp	/^class CompileShader : public LeafState$/;"	c	namespace:sword::state
CompileShaderCode	command/shader.hpp	/^class CompileShaderCode : public Command$/;"	c	namespace:sword::command
Context	render/context.cpp	/^Context::Context(bool validate)$/;"	f	class:sword::render::Context
Context	render/context.hpp	/^class Context$/;"	c	namespace:sword::render
CopyAttachmentToDevice	command/transfer.hpp	/^class CopyAttachmentToDevice : public Command$/;"	c	namespace:sword::command
CopyAttachmentToUndoStack	command/saveimage.hpp	/^class CopyAttachmentToUndoStack : public Command$/;"	c	namespace:sword::command
CreateDescriptorSetLayout	command/rendercommands.hpp	/^class CreateDescriptorSetLayout : public Command$/;"	c	namespace:sword::command
CreateDescriptorSetLayout	state/descriptorsetlayoutmanager.cpp	/^CreateDescriptorSetLayout::CreateDescriptorSetLayout(StateArgs sa, $/;"	f	class:sword::state::CreateDescriptorSetLayout
CreateDescriptorSetLayout	state/descriptorsetlayoutmanager.hpp	/^class CreateDescriptorSetLayout : public LeafState$/;"	c	namespace:sword::state
CreateFrameDescriptorSets	command/rendercommands.hpp	/^class CreateFrameDescriptorSets : public Command$/;"	c	namespace:sword::command
CreateFrameDescriptorSets	state/descriptormanager.cpp	/^CreateFrameDescriptorSets::CreateFrameDescriptorSets(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::CreateFrameDescriptorSets
CreateFrameDescriptorSets	state/descriptormanager.hpp	/^class CreateFrameDescriptorSets : public LeafState$/;"	c	namespace:sword::state
CreateGraphicsPipeline	command/rendercommands.hpp	/^class CreateGraphicsPipeline : public Command$/;"	c	namespace:sword::command
CreateGraphicsPipeline	state/pipelinemanager.cpp	/^CreateGraphicsPipeline::CreateGraphicsPipeline(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::CreateGraphicsPipeline
CreateGraphicsPipeline	state/pipelinemanager.hpp	/^class CreateGraphicsPipeline : public LeafState$/;"	c	namespace:sword::state
CreateOffscreenRenderpass	command/rendercommands.hpp	/^class CreateOffscreenRenderpass : public Command$/;"	c	namespace:sword::command
CreatePipelineLayout	command/rendercommands.hpp	/^class CreatePipelineLayout : public Command$/;"	c	namespace:sword::command
CreatePipelineLayout	state/pipelinemanager.cpp	/^CreatePipelineLayout::CreatePipelineLayout(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::CreatePipelineLayout
CreateRenderLayer	command/rendercommands.hpp	/^class CreateRenderLayer : public Command$/;"	c	namespace:sword::command
CreateRenderLayer	state/rendermanager.cpp	/^CreateRenderLayer::CreateRenderLayer(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::CreateRenderLayer
CreateRenderLayer	state/rendermanager.hpp	/^class CreateRenderLayer : public LeafState$/;"	c	namespace:sword::state
CreateRenderPass	state/renderpassmanager.cpp	/^CreateRenderPass::CreateRenderPass(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::CreateRenderPass
CreateRenderPass	state/renderpassmanager.hpp	/^class CreateRenderPass : public LeafState$/;"	c	namespace:sword::state
CreateSwapchainRenderpass	command/rendercommands.hpp	/^class CreateSwapchainRenderpass : public Command$/;"	c	namespace:sword::command
DISPATCHER_HPP	event/dispatcher.hpp	2;"	d
DependencyGraph	render/dependencygraph.hpp	/^class DependencyGraph$/;"	c	namespace:sword::render
DescriptorManager	state/descriptormanager.cpp	/^DescriptorManager::DescriptorManager(StateArgs sa, Callbacks cb, ReportCallbackFn<DescriptorSetLayoutReport> dslrCb) :$/;"	f	class:sword::state::DescriptorManager
DescriptorSet	state/report.hpp	/^    DescriptorSet,$/;"	m	class:sword::state::ReportType
DescriptorSetLayout	state/report.hpp	/^    DescriptorSetLayout,$/;"	m	class:sword::state::ReportType
DescriptorSetLayoutManager	state/descriptorsetlayoutmanager.cpp	/^DescriptorSetLayoutManager::DescriptorSetLayoutManager(StateArgs sa, Callbacks cb, ReportCallbackFn<DescriptorSetLayoutReport> dslr) :$/;"	f	class:sword::state::DescriptorSetLayoutManager
DescriptorSetLayoutReport	state/report.hpp	/^    inline DescriptorSetLayoutReport($/;"	f	class:sword::state::DescriptorSetLayoutReport
DescriptorSetLayoutReport	state/report.hpp	/^class DescriptorSetLayoutReport : public Report$/;"	c	namespace:sword::state
DescriptorSetReport	state/report.hpp	/^    inline DescriptorSetReport($/;"	f	class:sword::state::DescriptorSetReport
DescriptorSetReport	state/report.hpp	/^class DescriptorSetReport : public Report$/;"	c	namespace:sword::state
Director	state/director.cpp	/^Director::Director(StateArgs sa, const StateStack& ss, render::Window& window) :$/;"	f	class:sword::state::Director
EDITSTACK_HPP_	state/editstack.hpp	2;"	d
EVENT_EVENT_HPP	event/event.hpp	2;"	d
EVENT_FILEWATCHER_HPP	event/filewatcher.hpp	2;"	d
EVENT_TYPES_HPP	event/types.hpp	2;"	d
EVENT_WATCHER_HPP	event/watcher.hpp	2;"	d
EditStack	state/editstack.hpp	/^class EditStack $/;"	c	namespace:sword::state
EnterWindow	event/event.hpp	/^    EnterWindow = 7,$/;"	m	class:sword::event::symbol::WindowEventType
Esc	event/event.hpp	/^    Esc = 9,$/;"	m	class:sword::event::symbol::Key
Event	event/event.hpp	/^class Event$/;"	c	namespace:sword::event::symbol
EventDispatcher	event/dispatcher.cpp	/^EventDispatcher::EventDispatcher(const render::Window& window):$/;"	f	class:sword::event::EventDispatcher
EventDispatcher	event/dispatcher.hpp	/^class EventDispatcher$/;"	c	namespace:sword::event
File	event/event.hpp	/^    File,$/;"	m	class:sword::event::symbol::Category
File	event/event.hpp	/^class File : public Event$/;"	c	namespace:sword::event::symbol
FileWatcher	event/filewatcher.cpp	/^FileWatcher::FileWatcher(EventQueue& queue) :$/;"	f	class:sword::event::FileWatcher
FileWatcher	event/filewatcher.hpp	/^class FileWatcher$/;"	c	namespace:sword::event
ForwardStack	types/stack.hpp	/^class ForwardStack : public Stack<T>$/;"	c	namespace:sword
FragShader	render/shader.cpp	/^FragShader::FragShader(const vk::Device& device, std::string filepath) :$/;"	f	class:sword::render::FragShader
FragShader	render/shader.cpp	/^FragShader::FragShader(const vk::Device& device, std::vector<uint32_t>&& code) :$/;"	f	class:sword::render::FragShader
FragShader	render/shader.hpp	/^class FragShader : public Shader$/;"	c	namespace:sword::render
FragmentInput	state/painter.hpp	/^struct FragmentInput$/;"	s	namespace:sword::state::painter
GLM_ENABLE_EXPERIMENTAL	state/painter.hpp	6;"	d
GLSLC	util/defs.hpp	7;"	d
GraphicsPipeline	render/pipeline.cpp	/^GraphicsPipeline::GraphicsPipeline($/;"	f	class:sword::render::GraphicsPipeline
GraphicsPipeline	render/pipeline.cpp	/^GraphicsPipeline::GraphicsPipeline(GraphicsPipeline&& other) :$/;"	f	class:sword::render::GraphicsPipeline
GraphicsPipeline	render/pipeline.hpp	/^class GraphicsPipeline$/;"	c	namespace:sword::render
GraphicsPipelineReport	state/report.hpp	/^    GraphicsPipelineReport($/;"	f	class:sword::state::GraphicsPipelineReport
GraphicsPipelineReport	state/report.hpp	/^class GraphicsPipelineReport : public Report$/;"	c	namespace:sword::state
Heap	types/heap.hpp	/^class Heap$/;"	c	namespace:sword
Image	render/resource.cpp	/^Image::Image(	$/;"	f	class:sword::render::Image
Image	render/resource.cpp	/^Image::Image($/;"	f	class:sword::render::Image
InitFrameUbos	command/rendercommands.hpp	/^class InitFrameUbos : public Command$/;"	c	namespace:sword::command
InitFrameUbos	state/descriptormanager.cpp	/^InitFrameUbos::InitFrameUbos(StateArgs sa) :$/;"	f	class:sword::state::InitFrameUbos
InitFrameUbos	state/descriptormanager.hpp	/^class InitFrameUbos : public LeafState$/;"	c	namespace:sword::state
Input	state/painter.cpp	/^enum class Input : uint8_t$/;"	c	namespace:sword::state::painter	file:
InputMode	event/event.hpp	/^enum class InputMode : uint8_t$/;"	c	namespace:sword::event::symbol
Key	event/event.hpp	/^enum class Key : uint8_t$/;"	c	namespace:sword::event::symbol
Keyboard	event/event.hpp	/^class Keyboard : public Window$/;"	c	namespace:sword::event::symbol
Keypress	event/event.hpp	/^    Keypress = 2,$/;"	m	class:sword::event::symbol::WindowEventType
Keyrelease	event/event.hpp	/^    Keyrelease = 3,$/;"	m	class:sword::event::symbol::WindowEventType
LeafState	state/state.hpp	/^    LeafState(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::LeafState
LeafState	state/state.hpp	/^class LeafState : public State$/;"	c	namespace:sword::state
LeaveWindow	event/event.hpp	/^    LeaveWindow = 8,$/;"	m	class:sword::event::symbol::WindowEventType
LeaveWindow	event/event.hpp	/^class LeaveWindow : public Window$/;"	c	namespace:sword::event::symbol
Left	event/event.hpp	/^    Left = 1,$/;"	m	class:sword::event::symbol::MouseButton
LoadFragShader	command/rendercommands.hpp	/^class LoadFragShader: public Command$/;"	c	namespace:sword::command
LoadFragShaders	state/shader.cpp	/^LoadFragShaders::LoadFragShaders(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::LoadFragShaders
LoadFragShaders	state/shader.hpp	/^class LoadFragShaders : public LeafState$/;"	c	namespace:sword::state
LoadVertShader	command/rendercommands.hpp	/^class LoadVertShader: public Command$/;"	c	namespace:sword::command
LoadVertShaders	state/shader.cpp	/^LoadVertShaders::LoadVertShaders(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::LoadVertShaders
LoadVertShaders	state/shader.hpp	/^class LoadVertShaders : public LeafState$/;"	c	namespace:sword::state
Matrices	state/painter.hpp	/^struct Matrices$/;"	s	namespace:sword::state::painter
Middle	event/event.hpp	/^    Middle = 2,$/;"	m	class:sword::event::symbol::MouseButton
Motion	event/event.hpp	/^    Motion = 6,$/;"	m	class:sword::event::symbol::WindowEventType
MouseButton	event/event.hpp	/^class MouseButton : public Window$/;"	c	namespace:sword::event::symbol
MouseButton	event/event.hpp	/^enum class MouseButton : uint8_t$/;"	c	namespace:sword::event::symbol
MousePress	event/event.hpp	/^    MousePress = 4,$/;"	m	class:sword::event::symbol::WindowEventType
MouseRelease	event/event.hpp	/^    MouseRelease = 5,$/;"	m	class:sword::event::symbol::WindowEventType
Name	command/template.hpp	/^class Name : public Command$/;"	c	namespace:sword::command
Nothing	event/event.hpp	/^    Nothing,$/;"	m	class:sword::event::symbol::Category
Nothing	event/event.hpp	/^class Nothing : public Event$/;"	c	namespace:sword::event::symbol
Op	state/descriptormanager.hpp	/^    enum class Op : Option {createFrameDescriptorSets, printReports, descriptorSetLayoutMgr, initFrameUBOs, updateFrameSamplers};$/;"	c	class:sword::state::final
Op	state/descriptorsetlayoutmanager.hpp	/^    enum class Op : Option {createBinding, createDescriptorSetLayout, printReports};$/;"	c	class:sword::state::final
Op	state/director.hpp	/^    enum class Op : Option {painter, pushRenderManager, printHierarchy, quickSetup, quickSetup2, quickSetup3};$/;"	c	class:sword::state::final
Op	state/painter.hpp	/^    enum class Op : Option {initBasic, paint, brushResize, saveAttachmentToPng};$/;"	c	class:sword::state::painter::final
Op	state/pipelinemanager.hpp	/^    enum class Op : Option {createPipelineLayout, createGraphicsPipeline, printReports};$/;"	c	class:sword::state::final
Op	state/rendermanager.hpp	/^    enum class Op : Option {saveSwapImage, printReports, render, openWindow, prepRenderFrames, shaderManager, $/;"	c	class:sword::state::final
Op	state/renderpassmanager.hpp	/^    enum class Op : Option {createSwapRpass, createOffscreenRpass, printReports};$/;"	c	class:sword::state::final
Op	state/shader.hpp	/^    enum class Op : Option {watchFile, compileShader, printShader, loadFrag, loadVert, setSpecInt, setSpecFloat, printReports};$/;"	c	class:sword::state::final
OpenWindow	command/rendercommands.hpp	/^class OpenWindow : public Command$/;"	c	namespace:sword::command
OpenWindow	state/rendermanager.cpp	/^OpenWindow::OpenWindow(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::OpenWindow
OpenWindow	state/rendermanager.hpp	/^class OpenWindow : public BriefState$/;"	c	namespace:sword::state
OptionMap	state/state.hpp	/^    OptionMap(std::initializer_list<Element> init) :$/;"	f	class:sword::state::OptionMap
OptionMap	state/state.hpp	/^class OptionMap$/;"	c	namespace:sword::state
P	event/event.hpp	/^    P = 33$/;"	m	class:sword::event::symbol::Key
Paint	state/painter.cpp	/^Paint::Paint(StateArgs sa, Callbacks cb, PainterVars& vars) :$/;"	f	class:sword::state::painter::Input::Paint	file:
Paint	state/painter.hpp	/^class Paint : public LeafState$/;"	c	namespace:sword::state::painter
Painter	state/painter.cpp	/^Painter::Painter(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::painter::Input::Painter	file:
PainterVars	state/painter.hpp	/^struct PainterVars$/;"	s	namespace:sword::state::painter
Pipeline	state/report.hpp	/^    Pipeline,$/;"	m	class:sword::state::ReportType
PipelineLayoutReport	state/report.hpp	/^    PipelineLayoutReport(std::string name, std::vector<std::string> dlnames) : name{name}, descriptorSetLayouts{dlnames} {}$/;"	f	class:sword::state::PipelineLayoutReport
PipelineLayoutReport	state/report.hpp	/^class PipelineLayoutReport : public Report$/;"	c	namespace:sword::state
PipelineManager	state/pipelinemanager.cpp	/^PipelineManager::PipelineManager(StateArgs sa, Callbacks cb, ReportCallbackFn<GraphicsPipelineReport> rpcb) :$/;"	f	class:sword::state::PipelineManager
Pool	types/pool.hpp	/^    Pool() {}$/;"	f	class:sword::Pool
Pool	types/pool.hpp	/^    Pool(render::CommandPool&& gpuPool) $/;"	f	class:sword::Pool
Pool	types/pool.hpp	/^class Pool$/;"	c	namespace:sword
PopVocab	command/vocab.hpp	/^class PopVocab : public Command$/;"	c	namespace:sword::command
PrepareRenderFrames	command/rendercommands.hpp	/^class PrepareRenderFrames : public Command$/;"	c	namespace:sword::command
PrepareRenderFrames	state/rendermanager.cpp	/^PrepareRenderFrames::PrepareRenderFrames(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::PrepareRenderFrames
PrepareRenderFrames	state/rendermanager.hpp	/^class PrepareRenderFrames : public BriefState$/;"	c	namespace:sword::state
PrintShader	state/shader.cpp	/^PrintShader::PrintShader(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::PrintShader
PrintShader	state/shader.hpp	/^class PrintShader : public LeafState$/;"	c	namespace:sword::state
QueueInfo	render/context.hpp	/^    QueueInfo(int familyIndex, vk::QueueFlags flags, int queueCount) :$/;"	f	struct:sword::render::QueueInfo
QueueInfo	render/context.hpp	/^struct QueueInfo$/;"	s	namespace:sword::render
QuickSetup	state/director.cpp	/^QuickSetup::QuickSetup(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::QuickSetup
QuickSetup	state/director.hpp	/^class QuickSetup : public BriefState$/;"	c	namespace:sword::state
R	event/event.hpp	/^    R = 27,$/;"	m	class:sword::event::symbol::Key
RECORDRENDERCOMMAND_HPP_	command/recordrendercommand.hpp	2;"	d
RENDERCOMMANDS_HPP_	command/rendercommands.hpp	2;"	d
RENDER_ATTACHMENT_HPP	render/attachment.hpp	2;"	d
RENDER_COMMAND_HPP	render/command.hpp	2;"	d
RENDER_CONTEXT_H	render/context_test.hpp	2;"	d
RENDER_DEPENDENCYGRAPH_HPP	render/dependencygraph.hpp	2;"	d
RENDER_PIPELINE_HPP	render/pipeline.hpp	2;"	d
RENDER_RENDERER_HPP_	render/renderer.hpp	2;"	d
RENDER_RENDERFRAME_HPP	render/renderframe.hpp	2;"	d
RENDER_RENDERLAYER_HPP	render/renderlayer.hpp	2;"	d
RENDER_RENDERPASS_HPP_	render/renderpass.hpp	2;"	d
RENDER_RESOURCE_HPP_	render/resource.hpp	2;"	d
RENDER_SHADER_HPP_	render/shader.hpp	2;"	d
RENDER_SURFACE_WINDOW_HPP_	render/surface/window.hpp	2;"	d
RENDER_SWAPCHAIN_HPP_	render/swapchain.hpp	2;"	d
RENDER_TYPES_HPP	render/types.hpp	2;"	d
RENDER_UBOTYPES_HPP_	render/ubotypes.hpp	2;"	d
REPORT_HPP_	state/report.hpp	2;"	d
RL_DELAY	event/dispatcher.cpp	/^constexpr uint32_t RL_DELAY = 100;$/;"	m	namespace:sword::event	file:
RecordRenderCommand	command/recordrendercommand.hpp	/^class RecordRenderCommand : public Command$/;"	c	namespace:sword::command
RecordRenderCommand	command/rendercommands.hpp	/^class RecordRenderCommand : public Command$/;"	c	namespace:sword::command
RecordRenderCommand	state/rendermanager.cpp	/^RecordRenderCommand::RecordRenderCommand(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::RecordRenderCommand
RecordRenderCommand	state/rendermanager.hpp	/^class RecordRenderCommand : public LeafState$/;"	c	namespace:sword::state
RecordRenderCommandState	command/recordrendercommand.hpp	/^    RecordRenderCommandState(EditStack& es, CommandStack& cs, RendererManager& parent) :$/;"	f	class:sword::state::RecordRenderCommandState
RecordRenderCommandState	command/recordrendercommand.hpp	/^class RecordRenderCommandState : public LeafState$/;"	c	namespace:sword::state
Region	types/region.hpp	/^    Region(size_t initialSize)$/;"	f	class:sword::Region
Region	types/region.hpp	/^class Region$/;"	c	namespace:sword
Register	state/state.hpp	/^struct Register$/;"	s	namespace:sword::state
Render	command/rendercommands.hpp	/^class Render : public Command$/;"	c	namespace:sword::command
Render	state/rendermanager.cpp	/^Render::Render(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::Render
Render	state/rendermanager.hpp	/^class Render : public LeafState$/;"	c	namespace:sword::state
RenderCommand	state/report.hpp	/^    RenderCommand,$/;"	m	class:sword::state::ReportType
RenderCommandReport	state/report.hpp	/^    RenderCommandReport(int cmdIndex, std::vector<uint32_t> rpiIndices) :$/;"	f	class:sword::state::RenderCommandReport
RenderCommandReport	state/report.hpp	/^class RenderCommandReport : public Report$/;"	c	namespace:sword::state
RenderFrame	render/renderframe.cpp	/^RenderFrame::RenderFrame($/;"	f	class:sword::render::RenderFrame
RenderFrame	render/renderframe.cpp	/^RenderFrame::RenderFrame(RenderFrame&& other) :$/;"	f	class:sword::render::RenderFrame
RenderFrame	render/renderframe.hpp	/^class RenderFrame$/;"	c	namespace:sword::render
RenderLayer	render/renderlayer.cpp	/^RenderLayer::RenderLayer($/;"	f	class:sword::render::RenderLayer
RenderLayer	render/renderlayer.cpp	/^RenderLayer::RenderLayer(RenderLayer&& other) :$/;"	f	class:sword::render::RenderLayer
RenderLayer	render/renderlayer.hpp	/^class RenderLayer$/;"	c	namespace:sword::render
RenderLayerReport	state/report.hpp	/^    RenderLayerReport($/;"	f	class:sword::state::RenderLayerReport
RenderLayerReport	state/report.hpp	/^class RenderLayerReport : public Report$/;"	c	namespace:sword::state
RenderManager	state/rendermanager.cpp	/^RenderManager::RenderManager(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::RenderManager
RenderPass	render/renderpass.cpp	/^RenderPass::RenderPass(RenderPass&& other) :$/;"	f	class:sword::render::RenderPass
RenderPass	render/renderpass.cpp	/^RenderPass::RenderPass(const vk::Device& device, const std::string name) :$/;"	f	class:sword::render::RenderPass
RenderPass	render/renderpass.hpp	/^class RenderPass$/;"	c	namespace:sword::render
RenderPass	state/report.hpp	/^    RenderPass,$/;"	m	class:sword::state::ReportType
RenderPassManager	state/renderpassmanager.cpp	/^RenderPassManager::RenderPassManager(StateArgs sa, Callbacks cb, ReportCallbackFn<RenderPassReport> rpr) :$/;"	f	class:sword::state::RenderPassManager
RenderPassReport	state/report.hpp	/^    inline RenderPassReport(std::string n, Type t) :$/;"	f	class:sword::state::RenderPassReport
RenderPassReport	state/report.hpp	/^    inline RenderPassReport(std::string n, Type t, vk::AttachmentLoadOp loadOp) :$/;"	f	class:sword::state::RenderPassReport
RenderPassReport	state/report.hpp	/^class RenderPassReport : public Report$/;"	c	namespace:sword::state
RenderPassType	state/renderpassmanager.hpp	/^enum class RenderPassType : uint8_t {swapchain, offscreen};$/;"	c	namespace:sword::state
Renderer	render/renderer.cpp	/^Renderer::Renderer(Context& context) :$/;"	f	class:sword::render::Renderer
Renderer	render/renderer.hpp	/^class Renderer$/;"	c	namespace:sword::render
RenderpassInstance	state/report.hpp	/^    RenderpassInstance,$/;"	m	class:sword::state::ReportType
Report	state/report.hpp	/^class Report$/;"	c	namespace:sword::state
ReportType	state/report.hpp	/^enum class ReportType : uint8_t$/;"	c	namespace:sword::state
ReportUsage	state/report.hpp	/^enum class ReportUsage : uint8_t$/;"	c	namespace:sword::state
ResizeBrush	state/painter.cpp	/^ResizeBrush::ResizeBrush(StateArgs sa, Callbacks cb, PainterVars& vars) :$/;"	f	class:sword::state::painter::Input::ResizeBrush	file:
ResizeBrush	state/painter.hpp	/^class ResizeBrush : public LeafState$/;"	c	namespace:sword::state::painter
ReverseStack	types/stack.hpp	/^class ReverseStack : public Stack<T>$/;"	c	namespace:sword
Right	event/event.hpp	/^    Right = 3,$/;"	m	class:sword::event::symbol::MouseButton
Rotate	state/painter.cpp	/^Rotate::Rotate(StateArgs sa, Callbacks cb, PainterVars& vars) :$/;"	f	class:sword::state::painter::Input::Rotate	file:
Rotate	state/painter.hpp	/^class Rotate : public LeafState$/;"	c	namespace:sword::state::painter
S	event/event.hpp	/^    S = 39,$/;"	m	class:sword::event::symbol::Key
SHADER_DIR	util/defs.hpp	5;"	d
SHADER_SRC	util/defs.hpp	6;"	d
STATE_BASE	state/state.hpp	15;"	d
STATE_DESCRIPTORMANAGER_HPP	state/descriptormanager.hpp	2;"	d
STATE_DESCRIPTORSETLAYOUTMANAGER_HPP	state/descriptorsetlayoutmanager.hpp	2;"	d
STATE_DIRECTOR_HPP_	state/director.hpp	2;"	d
STATE_OPTION_HPP	state/option.hpp	2;"	d
STATE_PIPELINEMANAGER_HPP	state/pipelinemanager.hpp	3;"	d
STATE_RENDERMANAGER_HPP	state/rendermanager.hpp	2;"	d
STATE_RENDERPASSMANAGER_HPP	state/renderpassmanager.hpp	2;"	d
STATE_SHADER_HPP	state/shader.hpp	2;"	d
STATE_STATETYPES_HPP_	state/statetypes.hpp	2;"	d
STATE_STATE_HPP	state/state.hpp	2;"	d
STATE_VOCAB_HPP	state/vocab.hpp	2;"	d
SWD_DEBUG_MSG	util/debug.hpp	4;"	d
SWD_THREAD_MSG	util/outformat.hpp	7;"	d
SWORD	util/defs.hpp	4;"	d
SYMBOL	command/template.hpp	2;"	d
S_HEIGHT	state/painter.hpp	/^constexpr uint32_t S_HEIGHT = 800;$/;"	m	namespace:sword::state::painter
S_WIDTH	state/painter.hpp	/^constexpr uint32_t S_WIDTH = 800;$/;"	m	namespace:sword::state::painter
SaveAttachment	state/painter.cpp	/^SaveAttachment::SaveAttachment(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::painter::Input::SaveAttachment	file:
SaveAttachment	state/painter.hpp	/^class SaveAttachment : public LeafState$/;"	c	namespace:sword::state::painter
SaveAttachmentToPng	command/saveimage.hpp	/^class SaveAttachmentToPng : public Command$/;"	c	namespace:sword::command
SaveSwap	state/painter.cpp	/^SaveSwap::SaveSwap(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::painter::Input::SaveSwap	file:
SaveSwap	state/painter.hpp	/^class SaveSwap : public LeafState$/;"	c	namespace:sword::state::painter
SaveSwapImage	state/rendermanager.cpp	/^SaveSwapImage::SaveSwapImage(StateArgs sa, Callbacks cb) : $/;"	f	class:sword::state::SaveSwapImage
SaveSwapImage	state/rendermanager.hpp	/^class SaveSwapImage : public LeafState$/;"	c	namespace:sword::state
SaveSwapToPng	command/saveimage.hpp	/^class SaveSwapToPng : public Command$/;"	c	namespace:sword::command
Scale	state/painter.cpp	/^Scale::Scale(StateArgs sa, Callbacks cb, PainterVars& vars) :$/;"	f	class:sword::state::painter::Input::Scale	file:
Scale	state/painter.hpp	/^class Scale : public LeafState$/;"	c	namespace:sword::state::painter
SetDescriptorCount	state/descriptorsetlayoutmanager.cpp	/^SetDescriptorCount::SetDescriptorCount(StateArgs sa, Callbacks cb, vk::DescriptorSetLayoutBinding* const & binding) :$/;"	f	class:sword::state::SetDescriptorCount
SetDescriptorCount	state/descriptorsetlayoutmanager.hpp	/^class SetDescriptorCount : public LeafState$/;"	c	namespace:sword::state
SetOffscreenDim	command/rendercommands.hpp	/^class SetOffscreenDim : public Command$/;"	c	namespace:sword::command
SetShaderStageEntry	state/descriptorsetlayoutmanager.cpp	/^SetShaderStageEntry::SetShaderStageEntry(StateArgs sa, Callbacks cb, vk::DescriptorSetLayoutBinding* const & binding) :$/;"	f	class:sword::state::SetShaderStageEntry
SetShaderStageEntry	state/descriptorsetlayoutmanager.hpp	/^class SetShaderStageEntry : public LeafState$/;"	c	namespace:sword::state
SetSpec	state/shader.cpp	/^SetSpec::SetSpec(StateArgs sa, Callbacks cb, shader::SpecType t, ShaderReports& reports) :$/;"	f	class:sword::state::SetSpec
SetSpec	state/shader.hpp	/^class SetSpec : public LeafState$/;"	c	namespace:sword::state
SetSpecFloat	command/rendercommands.hpp	/^class SetSpecFloat: public Command$/;"	c	namespace:sword::command
SetSpecInt	command/rendercommands.hpp	/^class SetSpecInt: public Command$/;"	c	namespace:sword::command
SetStateType	state/descriptorsetlayoutmanager.cpp	/^SetStateType::SetStateType(StateArgs sa, Callbacks cb, vk::DescriptorSetLayoutBinding* const & binding) :$/;"	f	class:sword::state::SetStateType
SetStateType	state/descriptorsetlayoutmanager.hpp	/^class SetStateType : public LeafState$/;"	c	namespace:sword::state
SetVocab	command/vocab.hpp	/^class SetVocab : public Command$/;"	c	namespace:sword::command
Shader	render/shader.cpp	/^Shader::Shader(const vk::Device& device, std::string filepath) :$/;"	f	class:sword::render::Shader
Shader	render/shader.cpp	/^Shader::Shader(const vk::Device& device, std::vector<uint32_t>&& code) :$/;"	f	class:sword::render::Shader
Shader	render/shader.hpp	/^class Shader$/;"	c	namespace:sword::render
Shader	state/report.hpp	/^    Shader,$/;"	m	class:sword::state::ReportType
ShaderManager	state/shader.cpp	/^ShaderManager::ShaderManager(StateArgs sa, Callbacks cb, ReportCallbackFn<ShaderReport> srcb)  : $/;"	f	class:sword::state::ShaderManager
ShaderReport	state/report.hpp	/^    ShaderReport(std::string n, ShaderType t, int i0, int i1, float f0, float f1, std::string path = "unknown") :$/;"	f	class:sword::state::final
ShaderType	render/renderer.hpp	/^enum class ShaderType {vert, frag};$/;"	c	namespace:sword::render
ShaderType	util/enum.hpp	/^enum class ShaderType : uint8_t {frag, vert};$/;"	c	namespace:sword
Shift_L	event/event.hpp	/^    Shift_L = 50,$/;"	m	class:sword::event::symbol::Key
SmallMap	types/map.hpp	/^    SmallMap(std::initializer_list<Element> avail) : options{avail} {}$/;"	f	class:sword::SmallMap
SmallMap	types/map.hpp	/^class SmallMap$/;"	c	namespace:sword
SpecData	render/shader.hpp	/^struct SpecData$/;"	s	namespace:sword::render
SpecType	state/shader.hpp	/^    enum class SpecType : uint8_t {integer, floating};$/;"	c	class:sword::state::final
SpecType	state/shader.hpp	/^    enum class SpecType : uint8_t {integer, floating};$/;"	c	namespace:sword::state::shader
Spirv	types/spirv.hpp	/^class Spirv$/;"	c	namespace:sword
Stack	types/stack.hpp	/^class Stack$/;"	c	namespace:sword
State	state/state.hpp	/^    State(CommandStack& cs) : cmdStack{cs} {}$/;"	f	class:sword::state::State
State	state/state.hpp	/^    State(CommandStack& cs, ExitCallbackFn callback) : cmdStack{cs}, onExitCallback{callback} {}$/;"	f	class:sword::state::State
State	state/state.hpp	/^class State$/;"	c	namespace:sword::state
StateArgs	state/state.hpp	/^struct StateArgs$/;"	s	namespace:sword::state
StateType	state/state.hpp	/^enum class StateType : uint8_t {leaf, branch, brief};$/;"	c	namespace:sword::state
Swapchain	render/swapchain.cpp	/^Swapchain::Swapchain(const Context& context, const Window& window, const uint8_t count) :$/;"	f	class:sword::render::Swapchain
Swapchain	render/swapchain.hpp	/^class Swapchain$/;"	c	namespace:sword::render
TYPES_MAP_HPP	types/map.hpp	2;"	d
TYPES_POOL_H_	types/pool.hpp	2;"	d
TYPES_SPIRV_HPP	types/spirv.hpp	2;"	d
TYPES_STACK_HPP_	types/stack.hpp	2;"	d
TYPES_VKTYPES_HPP	types/vktypes.hpp	2;"	d
TargetType	render/renderer.hpp	/^enum class TargetType {offscreen, swapchain};$/;"	c	namespace:sword::render
Timer	util.hpp	/^class Timer$/;"	c	namespace:sword
Translate	state/painter.cpp	/^Translate::Translate(StateArgs sa, Callbacks cb, PainterVars& vars) : $/;"	f	class:sword::state::painter::Input::Translate	file:
Translate	state/painter.hpp	/^class Translate : public LeafState$/;"	c	namespace:sword::state::painter
Type	state/report.hpp	/^    enum class Type : uint8_t {frameOwned, rendererOwned};$/;"	c	class:sword::state::DescriptorSetReport
Type	state/report.hpp	/^    enum class Type : uint8_t {swapchain, offscreen}; $/;"	c	class:sword::state::RenderPassReport
UTIL_DEBUG_HPP	util/debug.hpp	2;"	d
UTIL_DEFS_HPP	util/defs.hpp	2;"	d
UTIL_ENUM_HPP	util/enum.hpp	2;"	d
UTIL_FILE_HPP	util/file.hpp	2;"	d
UTIL_H	util.hpp	2;"	d
UTIL_OUTFORMAT_HPP	util/outformat.hpp	2;"	d
UTIL_STRINGUTIL_HPP	util/stringutil.hpp	2;"	d
Ubo	render/renderer.hpp	/^struct Ubo$/;"	s	namespace:sword::render
UpdateFrameSamplers	command/rendercommands.hpp	/^class UpdateFrameSamplers : public Command$/;"	c	namespace:sword::command
UpdateFrameSamplers	state/descriptormanager.cpp	/^UpdateFrameSamplers::UpdateFrameSamplers(StateArgs sa) :$/;"	f	class:sword::state::UpdateFrameSamplers
UpdateFrameSamplers	state/descriptormanager.hpp	/^class UpdateFrameSamplers : public LeafState$/;"	c	namespace:sword::state
UpdateVocab	command/vocab.hpp	/^class UpdateVocab : public Command$/;"	c	namespace:sword::command
VK_USE_PLATFORM_XCB_KHR	render/context.hpp	4;"	d
VK_USE_PLATFORM_XCB_KHR	types/vktypes.hpp	4;"	d
VertShader	render/shader.cpp	/^VertShader::VertShader(const vk::Device& device, std::string filepath) :$/;"	f	class:sword::render::VertShader
VertShader	render/shader.cpp	/^VertShader::VertShader(const vk::Device& device, std::vector<uint32_t>&& code) :$/;"	f	class:sword::render::VertShader
VertShader	render/shader.hpp	/^class VertShader : public Shader$/;"	c	namespace:sword::render
Vocab	state/vocab.hpp	/^class Vocab$/;"	c	namespace:sword::state
WatchFile	command/watcher.hpp	/^class WatchFile : public Command$/;"	c	namespace:sword::command
WatchFile	state/shader.cpp	/^WatchFile::WatchFile(StateArgs sa, Callbacks cb) :$/;"	f	class:sword::state::WatchFile
WatchFile	state/shader.hpp	/^class WatchFile : public LeafState$/;"	c	namespace:sword::state
WatchTicket	event/filewatcher.hpp	/^struct WatchTicket$/;"	s	namespace:sword::event
Window	event/event.hpp	/^    Window,$/;"	m	class:sword::event::symbol::Category
Window	event/event.hpp	/^    Window,$/;"	m	class:sword::event::symbol::InputMode
Window	event/event.hpp	/^class Window: public Event$/;"	c	namespace:sword::event::symbol
Window	render/surface/window.cpp	/^Window::Window(uint16_t width, uint16_t height) :$/;"	f	class:sword::render::Window
Window	render/surface/window.hpp	/^class Window$/;"	c	namespace:sword::render
WindowEventType	event/event.hpp	/^enum class WindowEventType : uint8_t$/;"	c	namespace:sword::event::symbol
WindowInput	event/event.hpp	/^struct WindowInput$/;"	s	namespace:sword::event::symbol
_STATE_PAINTER_HPP	state/painter.hpp	3;"	d
aPool	event/dispatcher.hpp	/^    EventPool<Abort, 50> aPool;$/;"	m	class:sword::event::EventDispatcher
abortHelper	event/dispatcher.cpp	/^int abortHelper(int count, int key)$/;"	f	namespace:sword::event
acquireNextImage	render/swapchain.cpp	/^uint32_t Swapchain::acquireNextImage(vk::Semaphore semaphore, vk::Fence fence)$/;"	f	class:sword::render::Swapchain
activate	command/command.hpp	/^    void activate() {inUse = true;}$/;"	f	class:sword::command::Command
activate	event/event.hpp	/^    void activate() {inUse = true;}$/;"	f	class:sword::event::symbol::Event
activate	state/state.hpp	/^    void activate(Option op) { topMask.set(op); }$/;"	f	class:sword::state::BranchState
activateCreateSwap	state/renderpassmanager.cpp	/^void RenderPassManager::activateCreateSwap()$/;"	f	class:sword::state::RenderPassManager
activateDSetLayoutNeeding	state/descriptormanager.cpp	/^void DescriptorManager::activateDSetLayoutNeeding()$/;"	f	class:sword::state::DescriptorManager
activeTarget	render/renderer.hpp	/^    Attachment* activeTarget;$/;"	m	class:sword::render::Renderer
add	state/report.hpp	/^    add,$/;"	m	class:sword::state::ReportUsage
addAttachment	command/commandpools.hpp	/^    CommandPool<command::AddAttachment> addAttachment; $/;"	m	struct:sword::CommandPools
addRenderLayer	render/renderer.cpp	/^void Renderer::addRenderLayer($/;"	f	class:sword::render::Renderer
addRenderLayer	render/renderframe.cpp	/^void RenderFrame::addRenderLayer($/;"	f	class:sword::render::RenderFrame
addReport	state/state.hpp	/^    static void addReport(Report* ptr, std::vector<std::unique_ptr<R>>* derivedReports, ReportCallbackFn<R> callback = {})$/;"	f	class:sword::state::BranchState
addSubpassDependency	render/renderpass.cpp	/^void RenderPass::addSubpassDependency(vk::SubpassDependency d)$/;"	f	class:sword::render::RenderPass
addToVocab	state/state.hpp	/^    void addToVocab(std::string word) { State::addToVocab(word); }$/;"	f	class:sword::state::LeafState
addToVocab	state/state.hpp	/^    void addToVocab(std::string word) { vocab.push_back(word); }$/;"	f	class:sword::state::State
addVocab	event/dispatcher.cpp	/^void EventDispatcher::addVocab(const state::Vocab* vptr)$/;"	f	class:sword::event::EventDispatcher
addWatch	event/filewatcher.cpp	/^bool FileWatcher::addWatch(const char* path_str)$/;"	f	class:sword::event::FileWatcher
address	command/rendercommands.hpp	/^    void* address;$/;"	m	class:sword::command::BindUboData
allocateAndBindMemory	render/resource.cpp	/^void Buffer::allocateAndBindMemory()$/;"	f	class:sword::render::Buffer
appClass	render/surface/window.hpp	/^    std::string appClass = "floating";$/;"	m	class:sword::render::Window
appName	render/surface/window.hpp	/^	std::string appName = "aurora";$/;"	m	class:sword::render::Window
areaX	state/report.hpp	/^    uint32_t areaX;$/;"	m	class:sword::state::GraphicsPipelineReport
areaY	state/report.hpp	/^    uint32_t areaY;$/;"	m	class:sword::state::GraphicsPipelineReport
at	state/editstack.hpp	/^    State* at(int i) const { return stack.at(i); }$/;"	f	class:sword::state::EditStack
at	types/stack.hpp	/^    auto& at(size_t i) const {return this->items.at(i); }$/;"	f	class:sword::ForwardStack
at	types/stack.hpp	/^    auto& at(size_t i) const {return this->items.at(i); }$/;"	f	class:sword::ReverseStack
attachment	command/rendercommands.hpp	/^    std::string attachment;$/;"	m	class:sword::command::CreateRenderLayer
attachmentName	command/rendercommands.hpp	/^    std::string attachmentName;$/;"	m	class:sword::command::AddAttachment
attachmentName	command/saveimage.hpp	/^    std::string attachmentName;$/;"	m	class:sword::command::CopyAttachmentToUndoStack
attachmentName	command/saveimage.hpp	/^    std::string attachmentName;$/;"	m	class:sword::command::SaveAttachmentToPng
attachmentName	state/report.hpp	/^    std::string attachmentName;$/;"	m	class:sword::state::RenderLayerReport
attachmentNames	command/rendercommands.hpp	/^    std::vector<std::string> attachmentNames;$/;"	m	class:sword::command::UpdateFrameSamplers
attachmentStates	render/pipeline.hpp	/^    std::vector<vk::PipelineColorBlendAttachmentState> attachmentStates;$/;"	m	class:sword::render::GraphicsPipeline
attachments	render/renderer.hpp	/^    std::unordered_map<std::string, std::unique_ptr<Attachment>> attachments;$/;"	m	class:sword::render::Renderer
attachments	render/renderpass.hpp	/^    std::vector<vk::AttachmentDescription> attachments;$/;"	m	class:sword::render::RenderPass
avPool	state/state.hpp	/^    CommandPool<command::AddVocab> avPool;$/;"	m	class:sword::state::State
begin	render/command.cpp	/^void CommandBuffer::begin()$/;"	f	class:sword::render::CommandBuffer
begin	state/editstack.hpp	/^    auto begin() const { return stack.begin(); }$/;"	f	class:sword::state::EditStack
begin	types/map.hpp	/^    auto begin()$/;"	f	class:sword::SmallMap
begin	types/stack.hpp	/^    auto begin() const {return this->items.rbegin();}$/;"	f	class:sword::ReverseStack
begin	types/stack.hpp	/^    auto begin() {return this->items.begin();}$/;"	f	class:sword::ForwardStack
beginFrame	render/renderer.cpp	/^CommandBuffer& Renderer::beginFrame(uint32_t cmdId)$/;"	f	class:sword::render::Renderer
beginRenderPass	render/command.cpp	/^void CommandBuffer::beginRenderPass(vk::RenderPassBeginInfo& info)$/;"	f	class:sword::render::CommandBuffer
bindDescriptorSets	render/command.cpp	/^void CommandBuffer::bindDescriptorSets($/;"	f	class:sword::render::CommandBuffer
bindGraphicsPipeline	render/command.cpp	/^void CommandBuffer::bindGraphicsPipeline(const vk::Pipeline& pipeline)$/;"	f	class:sword::render::CommandBuffer
bindUboData	command/commandpools.hpp	/^    CommandPool<command::BindUboData> bindUboData;$/;"	m	struct:sword::CommandPools
bindUboData	render/renderer.cpp	/^void Renderer::bindUboData(void* dataPointer, uint32_t size, uint32_t index)$/;"	f	class:sword::render::Renderer
binding	command/rendercommands.hpp	/^    uint32_t binding;$/;"	m	class:sword::command::InitFrameUbos
binding	command/rendercommands.hpp	/^    uint32_t binding;$/;"	m	class:sword::command::UpdateFrameSamplers
binding	state/descriptorsetlayoutmanager.hpp	/^    vk::DescriptorSetLayoutBinding* const & binding;$/;"	m	class:sword::state::SetDescriptorCount::vk
binding	state/descriptorsetlayoutmanager.hpp	/^    vk::DescriptorSetLayoutBinding* const & binding;$/;"	m	class:sword::state::SetShaderStageEntry::vk
binding	state/descriptorsetlayoutmanager.hpp	/^    vk::DescriptorSetLayoutBinding* const & binding;$/;"	m	class:sword::state::SetStateType::vk
bindings	command/rendercommands.hpp	/^    std::vector<vk::DescriptorSetLayoutBinding> bindings;$/;"	m	class:sword::command::CreateDescriptorSetLayout
bindings	state/descriptorsetlayoutmanager.hpp	/^    std::vector<vk::DescriptorSetLayoutBinding> bindings;$/;"	m	class:sword::state::final
bindings	state/descriptorsetlayoutmanager.hpp	/^    std::vector<vk::DescriptorSetLayoutBinding>& bindings;$/;"	m	class:sword::state::CreateDescriptorSetLayout
bindings	state/report.hpp	/^    const std::vector<vk::DescriptorSetLayoutBinding> bindings;$/;"	m	class:sword::state::DescriptorSetLayoutReport
branch	state/state.hpp	/^enum class StateType : uint8_t {leaf, branch, brief};$/;"	m	class:sword::state::StateType
brushPosX	state/painter.hpp	/^    float& brushPosX;$/;"	m	class:sword::state::painter::Paint
brushPosX	state/painter.hpp	/^    float& brushPosX;$/;"	m	class:sword::state::painter::ResizeBrush
brushPosY	state/painter.hpp	/^    float& brushPosY;$/;"	m	class:sword::state::painter::Paint
brushPosY	state/painter.hpp	/^    float& brushPosY;$/;"	m	class:sword::state::painter::ResizeBrush
brushResize	state/painter.hpp	/^    enum class Op : Option {initBasic, paint, brushResize, saveAttachmentToPng};$/;"	m	class:sword::state::painter::final::Op
brushSize	state/painter.hpp	/^    float& brushSize;$/;"	m	class:sword::state::painter::ResizeBrush
brushStaticCmd	state/painter.hpp	/^    int brushStaticCmd;$/;"	m	struct:sword::state::painter::PainterVars
brushX	state/painter.hpp	/^    float brushX; \/\/mouseX in canvas space$/;"	m	struct:sword::state::painter::FragmentInput
brushY	state/painter.hpp	/^    float brushY; \/\/mouseY in canvas space$/;"	m	struct:sword::state::painter::FragmentInput
bufferBlock	render/renderframe.hpp	/^    BufferBlock* bufferBlock;$/;"	m	class:sword::render::RenderFrame
bufferBlocks	render/resource.hpp	/^    std::vector<std::unique_ptr<BufferBlock>> bufferBlocks;$/;"	m	class:sword::render::final
build	state/shader.hpp	/^    constexpr const char* build = SHADER_DIR;$/;"	m	namespace:sword::state::shader_dir
button	event/event.hpp	/^    symbol::MouseButton button;$/;"	m	class:sword::event::symbol::MouseButton
cMapX	state/painter.hpp	/^constexpr float cMapX = float(S_WIDTH) \/ float(C_WIDTH);$/;"	m	namespace:sword::state::painter
cMapY	state/painter.hpp	/^constexpr float cMapY = float(S_HEIGHT) \/ float(C_HEIGHT);$/;"	m	namespace:sword::state::painter
cdslPool	state/descriptorsetlayoutmanager.hpp	/^    CommandPool<command::CreateDescriptorSetLayout>& cdslPool;$/;"	m	class:sword::state::CreateDescriptorSetLayout
cfdsPool	state/descriptormanager.hpp	/^    CommandPool<command::CreateFrameDescriptorSets>& cfdsPool;$/;"	m	class:sword::state::CreateFrameDescriptorSets
cgpPool	state/pipelinemanager.hpp	/^    CommandPool<command::CreateGraphicsPipeline>& cgpPool;$/;"	m	class:sword::state::final
checkLayers	render/context.cpp	/^void Context::checkLayers(std::vector<const char*> layers)$/;"	f	class:sword::render::Context
clCount	event/dispatcher.cpp	/^static int clCount = 0;$/;"	m	namespace:sword::event	file:
clPool	event/dispatcher.hpp	/^    EventPool<CommandLine, 200> clPool;$/;"	m	class:sword::event::EventDispatcher
clear	state/editstack.hpp	/^    void clear() { stack.clear(); }$/;"	f	class:sword::state::EditStack
clear	state/vocab.hpp	/^    void clear() { words.clear(); }$/;"	f	class:sword::state::Vocab
clear	types/stack.hpp	/^    void clear() { items.clear(); }$/;"	f	class:sword::Stack
clearRenderLayers	render/renderer.cpp	/^void Renderer::clearRenderLayers()$/;"	f	class:sword::render::Renderer
clearRenderPassInstances	render/renderframe.cpp	/^void RenderFrame::clearRenderPassInstances()$/;"	f	class:sword::render::RenderFrame
clearValue	render/renderpass.hpp	/^    vk::ClearValue clearValue;$/;"	m	class:sword::render::RenderPass
clearVocab	state/state.hpp	/^    void clearVocab() { vocab.clear(); }$/;"	f	class:sword::state::State
cmd	command/recordrendercommand.hpp	/^    command::RecordRenderCommand cmd;$/;"	m	class:sword::state::RecordRenderCommandState
cmdBufferId	command/recordrendercommand.hpp	/^    int cmdBufferId;$/;"	m	class:sword::command::RecordRenderCommand
cmdBufferId	command/rendercommands.hpp	/^    int cmdBufferId;$/;"	m	class:sword::command::RecordRenderCommand
cmdIndex	state/report.hpp	/^    int cmdIndex;$/;"	m	class:sword::state::RenderCommandReport
cmdPools	application.hpp	/^    CommandPools cmdPools;$/;"	m	class:sword::Application
cmdStack	application.hpp	/^    CommandStack cmdStack;$/;"	m	class:sword::Application
cmdStack	state/state.hpp	/^    CommandStack& cmdStack;$/;"	m	class:sword::state::LeafState
cmdStack	state/state.hpp	/^    CommandStack& cmdStack;$/;"	m	class:sword::state::State
code	types/spirv.hpp	/^    std::vector<uint32_t> code;$/;"	m	class:sword::Spirv
codeSize	render/shader.hpp	/^    size_t codeSize;$/;"	m	class:sword::render::Shader
colorAttachments	render/renderpass.hpp	/^    std::vector<vk::AttachmentDescription> colorAttachments;$/;"	m	class:sword::render::RenderPass
colorBlendState	render/pipeline.hpp	/^    vk::PipelineColorBlendStateCreateInfo colorBlendState;$/;"	m	class:sword::render::GraphicsPipeline
colorFormat	render/swapchain.hpp	/^	vk::Format colorFormat;$/;"	m	class:sword::render::Swapchain
colorSpace	render/swapchain.hpp	/^	vk::ColorSpaceKHR colorSpace;$/;"	m	class:sword::render::Swapchain
command	command/command.hpp	/^namespace command $/;"	n	namespace:sword
command	command/recordrendercommand.hpp	/^namespace command$/;"	n	namespace:sword
command	command/rendercommands.cpp	/^namespace command$/;"	n	namespace:sword	file:
command	command/rendercommands.hpp	/^namespace command$/;"	n	namespace:sword
command	command/saveimage.cpp	/^namespace command$/;"	n	namespace:sword	file:
command	command/saveimage.hpp	/^namespace command$/;"	n	namespace:sword
command	command/shader.cpp	/^namespace command$/;"	n	namespace:sword	file:
command	command/shader.hpp	/^namespace command$/;"	n	namespace:sword
command	command/template.hpp	/^namespace command$/;"	n	namespace:sword
command	command/transfer.cpp	/^namespace command$/;"	n	namespace:sword	file:
command	command/transfer.hpp	/^namespace command$/;"	n	namespace:sword
command	command/vocab.cpp	/^namespace command$/;"	n	namespace:sword	file:
command	command/vocab.hpp	/^namespace command$/;"	n	namespace:sword
command	command/watcher.cpp	/^namespace command$/;"	n	namespace:sword	file:
command	command/watcher.hpp	/^namespace command$/;"	n	namespace:sword
commandLineInput	event/dispatcher.hpp	/^    std::string commandLineInput;$/;"	m	class:sword::event::EventDispatcher
commandPool	render/renderer.hpp	/^    CommandPool commandPool;$/;"	m	class:sword::render::Renderer
commandPool	render/renderframe.hpp	/^    CommandPool commandPool;$/;"	m	class:sword::render::RenderFrame
compileOptions	command/shader.hpp	/^    shaderc::CompileOptions compileOptions;$/;"	m	class:sword::command::CompileShader
compileShader	command/commandpools.hpp	/^    CommandPool<command::CompileShader> compileShader;$/;"	m	struct:sword::CommandPools
compileShader	state/shader.hpp	/^    CompileShader compileShader;$/;"	m	class:sword::state::final
compileShader	state/shader.hpp	/^    enum class Op : Option {watchFile, compileShader, printShader, loadFrag, loadVert, setSpecInt, setSpecFloat, printReports};$/;"	m	class:sword::state::final::Op
compileShader	state/state.hpp	/^    const CompileShader* compileShader;$/;"	m	struct:sword::state::Register
compileShaderCode	command/commandpools.hpp	/^    CommandPool<command::CompileShaderCode> compileShaderCode;$/;"	m	struct:sword::CommandPools
completer	event/dispatcher.cpp	/^char** EventDispatcher::completer(const char* text, int start, int end)$/;"	f	class:sword::event::EventDispatcher
completion_generator	event/dispatcher.cpp	/^char* EventDispatcher::completion_generator(const char* text, int state)$/;"	f	class:sword::event::EventDispatcher
computeQueueInfo	render/context.hpp	/^    std::optional<QueueInfo> computeQueueInfo;$/;"	m	class:sword::render::Context
connection	render/surface/window.hpp	/^	xcb_connection_t* connection;$/;"	m	class:sword::render::Window
containsRenderLayer	state/report.hpp	/^    bool containsRenderLayer(int i) const $/;"	f	class:sword::state::RenderCommandReport
context	application.hpp	/^    render::Context context;$/;"	m	class:sword::Application
context	render/renderer.hpp	/^    const Context& context;$/;"	m	class:sword::render::Renderer
context	render/renderframe.hpp	/^    const Context& context;$/;"	m	class:sword::render::RenderFrame
context	render/swapchain.hpp	/^	const Context& context;$/;"	m	class:sword::render::Swapchain
copyAttachmentToHost	render/renderer.cpp	/^BufferBlock* Renderer::copyAttachmentToHost($/;"	f	class:sword::render::Renderer
copyHostToAttachment	render/renderer.cpp	/^void Renderer::copyHostToAttachment(void* source, int size, std::string attachmentName, const vk::Rect2D region)$/;"	f	class:sword::render::Renderer
copyImageToBuffer	render/command.cpp	/^void CommandBuffer::copyImageToBuffer($/;"	f	class:sword::render::CommandBuffer
copySwapToHost	render/renderer.cpp	/^BufferBlock* Renderer::copySwapToHost()$/;"	f	class:sword::render::Renderer
copyTo	types/region.hpp	/^    void copyTo(void* src, int size)$/;"	f	class:sword::Region
corpPool	state/renderpassmanager.hpp	/^    CommandPool<command::CreateOffscreenRenderpass>& corpPool;$/;"	m	class:sword::state::CreateRenderPass
cp	state/director.hpp	/^    CommandPools& cp;$/;"	m	class:sword::state::QuickSetup
cp	state/director.hpp	/^    CommandPools& cp;$/;"	m	class:sword::state::final
cp	state/painter.hpp	/^    CommandPools& cp;$/;"	m	class:sword::state::painter::final
cp	state/state.hpp	/^    CommandPools& cp;$/;"	m	struct:sword::state::StateArgs
create	render/pipeline.cpp	/^void GraphicsPipeline::create()$/;"	f	class:sword::render::GraphicsPipeline
create	render/renderpass.cpp	/^void RenderPass::create()$/;"	f	class:sword::render::RenderPass
createAttachment	render/renderer.cpp	/^Attachment& Renderer::createAttachment($/;"	f	class:sword::render::Renderer
createBasicSubpassDependency	render/renderpass.cpp	/^void RenderPass::createBasicSubpassDependency()$/;"	f	class:sword::render::RenderPass
createBinding	state/descriptorsetlayoutmanager.cpp	/^void DescriptorSetLayoutManager::createBinding()$/;"	f	class:sword::state::DescriptorSetLayoutManager
createBinding	state/descriptorsetlayoutmanager.hpp	/^    enum class Op : Option {createBinding, createDescriptorSetLayout, printReports};$/;"	m	class:sword::state::final::Op
createColorAttachment	render/renderpass.cpp	/^void RenderPass::createColorAttachment($/;"	f	class:sword::render::RenderPass
createColorBlendAttachmentState	render/pipeline.cpp	/^vk::PipelineColorBlendAttachmentState GraphicsPipeline::createColorBlendAttachmentState()$/;"	f	class:sword::render::GraphicsPipeline
createColorBlendState	render/pipeline.cpp	/^vk::PipelineColorBlendStateCreateInfo GraphicsPipeline::createColorBlendState()$/;"	f	class:sword::render::GraphicsPipeline
createDefaultDescriptorSetLayout	render/renderer.cpp	/^void Renderer::createDefaultDescriptorSetLayout(const std::string name)$/;"	f	class:sword::render::Renderer
createDepthStencilState	render/pipeline.cpp	/^vk::PipelineDepthStencilStateCreateInfo GraphicsPipeline::createDepthStencilState()$/;"	f	class:sword::render::GraphicsPipeline
createDescriptorPool	render/renderer.cpp	/^void Renderer::createDescriptorPool()$/;"	f	class:sword::render::Renderer
createDescriptorPool	render/renderframe.cpp	/^void RenderFrame::createDescriptorPool()$/;"	f	class:sword::render::RenderFrame
createDescriptorSetLayout	command/commandpools.hpp	/^    CommandPool<command::CreateDescriptorSetLayout> createDescriptorSetLayout;$/;"	m	struct:sword::CommandPools
createDescriptorSetLayout	render/renderer.cpp	/^const std::string Renderer::createDescriptorSetLayout(const std::string name, const std::vector<vk::DescriptorSetLayoutBinding> bindings)$/;"	f	class:sword::render::Renderer
createDescriptorSetLayout	state/descriptorsetlayoutmanager.hpp	/^    CreateDescriptorSetLayout createDescriptorSetLayout;$/;"	m	class:sword::state::final
createDescriptorSetLayout	state/descriptorsetlayoutmanager.hpp	/^    enum class Op : Option {createBinding, createDescriptorSetLayout, printReports};$/;"	m	class:sword::state::final::Op
createDescriptorSetLayout	state/state.hpp	/^    const CreateDescriptorSetLayout* createDescriptorSetLayout;$/;"	m	struct:sword::state::Register
createDescriptorSets	render/renderframe.cpp	/^void RenderFrame::createDescriptorSets($/;"	f	class:sword::render::RenderFrame
createDevice	render/context.cpp	/^void Context::createDevice()$/;"	f	class:sword::render::Context
createFrameDescriptorSets	command/commandpools.hpp	/^    CommandPool<command::CreateFrameDescriptorSets> createFrameDescriptorSets;$/;"	m	struct:sword::CommandPools
createFrameDescriptorSets	render/renderer.cpp	/^void Renderer::createFrameDescriptorSets(const std::vector<std::string>setLayoutNames)$/;"	f	class:sword::render::Renderer
createFrameDescriptorSets	state/descriptormanager.hpp	/^    CreateFrameDescriptorSets createFrameDescriptorSets;$/;"	m	class:sword::state::final
createFrameDescriptorSets	state/descriptormanager.hpp	/^    enum class Op : Option {createFrameDescriptorSets, printReports, descriptorSetLayoutMgr, initFrameUBOs, updateFrameSamplers};$/;"	m	class:sword::state::final::Op
createFrameDescriptorSets	state/state.hpp	/^    const CreateFrameDescriptorSets* createFrameDescriptorSets;$/;"	m	struct:sword::state::Register
createGraphicsPipeline	command/commandpools.hpp	/^    CommandPool<command::CreateGraphicsPipeline> createGraphicsPipeline;$/;"	m	struct:sword::CommandPools
createGraphicsPipeline	render/renderer.cpp	/^bool Renderer::createGraphicsPipeline($/;"	f	class:sword::render::Renderer
createGraphicsPipeline	state/pipelinemanager.hpp	/^    CreateGraphicsPipeline createGraphicsPipeline;$/;"	m	class:sword::state::final
createGraphicsPipeline	state/pipelinemanager.hpp	/^    enum class Op : Option {createPipelineLayout, createGraphicsPipeline, printReports};$/;"	m	class:sword::state::final::Op
createGraphicsPipeline	state/state.hpp	/^    const CreateGraphicsPipeline* createGraphicsPipeline;$/;"	m	struct:sword::state::Register
createHostBuffer	render/renderer.cpp	/^void Renderer::createHostBuffer(uint32_t size)$/;"	f	class:sword::render::Renderer
createImageViews	render/swapchain.cpp	/^void Swapchain::createImageViews()$/;"	f	class:sword::render::Swapchain
createInputAssemblyState	render/pipeline.cpp	/^vk::PipelineInputAssemblyStateCreateInfo GraphicsPipeline::createInputAssemblyState()$/;"	f	class:sword::render::GraphicsPipeline
createInstance	render/context.cpp	/^void Context::createInstance()$/;"	f	class:sword::render::Context
createModule	render/shader.cpp	/^void Shader::createModule()$/;"	f	class:sword::render::Shader
createMultisampleState	render/pipeline.cpp	/^vk::PipelineMultisampleStateCreateInfo GraphicsPipeline::createMultisampleState()$/;"	f	class:sword::render::GraphicsPipeline
createOffscreenRenderpass	command/commandpools.hpp	/^    CommandPool<command::CreateOffscreenRenderpass> createOffscreenRenderpass;$/;"	m	struct:sword::CommandPools
createOffscreenRpass	state/renderpassmanager.hpp	/^    enum class Op : Option {createSwapRpass, createOffscreenRpass, printReports};$/;"	m	class:sword::state::final::Op
createOwnDescriptorSets	render/renderer.cpp	/^void Renderer::createOwnDescriptorSets(const std::vector<std::string>setLayoutNames)$/;"	f	class:sword::render::Renderer
createPhysicalDevice	render/context.cpp	/^void Context::createPhysicalDevice()$/;"	f	class:sword::render::Context
createPipelineLayout	command/commandpools.hpp	/^    CommandPool<command::CreatePipelineLayout> createPipelineLayout;$/;"	m	struct:sword::CommandPools
createPipelineLayout	render/renderer.cpp	/^const std::string Renderer::createPipelineLayout(const std::string name, const std::vector<std::string> setLayoutNames)$/;"	f	class:sword::render::Renderer
createPipelineLayout	state/pipelinemanager.hpp	/^    CreatePipelineLayout createPipelineLayout;$/;"	m	class:sword::state::final
createPipelineLayout	state/pipelinemanager.hpp	/^    enum class Op : Option {createPipelineLayout, createGraphicsPipeline, printReports};$/;"	m	class:sword::state::final::Op
createPipelineLayout	state/state.hpp	/^    const CreatePipelineLayout* createPipelineLayout;$/;"	m	struct:sword::state::Register
createRasterizationState	render/pipeline.cpp	/^vk::PipelineRasterizationStateCreateInfo GraphicsPipeline::createRasterizationState()$/;"	f	class:sword::render::GraphicsPipeline
createRenderLayer	command/commandpools.hpp	/^    CommandPool<command::CreateRenderLayer> createRenderLayer;$/;"	m	struct:sword::CommandPools
createRenderLayer	state/rendermanager.hpp	/^        descriptorManager, renderPassManager, pipelineManager, createRenderLayer, recordRenderCommand};$/;"	m	class:sword::state::final::Op
createRenderLayer	state/rendermanager.hpp	/^    CreateRenderLayer createRenderLayer;$/;"	m	class:sword::state::final
createRenderLayer	state/state.hpp	/^    const CreateRenderLayer* createRenderLayer;$/;"	m	struct:sword::state::Register
createRenderPass	render/renderer.cpp	/^RenderPass& Renderer::createRenderPass(std::string name)$/;"	f	class:sword::render::Renderer
createRenderPass	state/renderpassmanager.hpp	/^    CreateRenderPass createRenderPass;$/;"	m	class:sword::state::final
createRenderPass	state/state.hpp	/^    const CreateRenderPass* createRenderPass;$/;"	m	struct:sword::state::Register
createSubpass	render/renderpass.cpp	/^void RenderPass::createSubpass()$/;"	f	class:sword::render::RenderPass
createSurface	render/swapchain.cpp	/^void Swapchain::createSurface()$/;"	f	class:sword::render::Swapchain
createSwapRpass	state/renderpassmanager.hpp	/^    enum class Op : Option {createSwapRpass, createOffscreenRpass, printReports};$/;"	m	class:sword::state::final::Op
createSwapchain	render/swapchain.cpp	/^void Swapchain::createSwapchain()$/;"	f	class:sword::render::Swapchain
createSwapchainRenderpass	command/commandpools.hpp	/^    CommandPool<command::CreateSwapchainRenderpass> createSwapchainRenderpass;$/;"	m	struct:sword::CommandPools
createVertexInputState	render/pipeline.cpp	/^vk::PipelineVertexInputStateCreateInfo GraphicsPipeline::createVertexInputState($/;"	f	class:sword::render::GraphicsPipeline
createViewport	render/pipeline.cpp	/^vk::Viewport GraphicsPipeline::createViewport(const vk::Rect2D& renderArea)$/;"	f	class:sword::render::GraphicsPipeline
createViewportState	render/pipeline.cpp	/^vk::PipelineViewportStateCreateInfo GraphicsPipeline::createViewportState()$/;"	f	class:sword::render::GraphicsPipeline
createWindow	render/surface/window.cpp	/^void Window::createWindow(const int width, const int height)$/;"	f	class:sword::render::Window
crlPool	state/rendermanager.hpp	/^    CommandPool<command::CreateRenderLayer>& crlPool;$/;"	m	class:sword::state::CreateRenderLayer
cs	state/state.hpp	/^    CommandStack& cs;$/;"	m	struct:sword::state::StateArgs
csPool	state/shader.hpp	/^    CommandPool<command::CompileShader>& csPool;$/;"	m	class:sword::state::final
csrpPool	state/renderpassmanager.hpp	/^    CommandPool<command::CreateSwapchainRenderpass>& csrpPool;$/;"	m	class:sword::state::CreateRenderPass
curBinding	state/descriptorsetlayoutmanager.hpp	/^    vk::DescriptorSetLayoutBinding* curBinding;$/;"	m	class:sword::state::final
data	render/renderer.hpp	/^    void* data;$/;"	m	struct:sword::render::Ubo
deactivate	state/state.hpp	/^    void deactivate(Option op) { topMask.reset(op); }$/;"	f	class:sword::state::BranchState
debugCallback	render/context.cpp	/^static VKAPI_ATTR VkBool32 VKAPI_CALL debugCallback($/;"	f	namespace:sword::render
debugMessenger	render/context.hpp	/^    VkDebugUtilsMessengerEXT debugMessenger;$/;"	m	class:sword::render::Context
depthStencilState	render/pipeline.hpp	/^    vk::PipelineDepthStencilStateCreateInfo depthStencilState;$/;"	m	class:sword::render::GraphicsPipeline
descSetLayoutNames	state/report.hpp	/^    const std::vector<std::string> descSetLayoutNames;$/;"	m	class:sword::state::DescriptorSetReport
descriptionIsBound	render/renderer.hpp	/^    bool descriptionIsBound;$/;"	m	class:sword::render::Renderer
descriptorManager	state/rendermanager.hpp	/^        descriptorManager, renderPassManager, pipelineManager, createRenderLayer, recordRenderCommand};$/;"	m	class:sword::state::final::Op
descriptorManager	state/rendermanager.hpp	/^    DescriptorManager descriptorManager;$/;"	m	class:sword::state::final
descriptorPool	render/renderer.hpp	/^    vk::DescriptorPool descriptorPool;$/;"	m	class:sword::render::Renderer
descriptorPool	render/renderframe.hpp	/^    vk::DescriptorPool descriptorPool;$/;"	m	class:sword::render::RenderFrame
descriptorSetLayoutMgr	state/descriptormanager.hpp	/^    DescriptorSetLayoutManager descriptorSetLayoutMgr;$/;"	m	class:sword::state::final
descriptorSetLayoutMgr	state/descriptormanager.hpp	/^    enum class Op : Option {createFrameDescriptorSets, printReports, descriptorSetLayoutMgr, initFrameUBOs, updateFrameSamplers};$/;"	m	class:sword::state::final::Op
descriptorSetLayoutNames	command/rendercommands.hpp	/^    std::vector<std::string> descriptorSetLayoutNames;$/;"	m	class:sword::command::CreatePipelineLayout
descriptorSetLayoutReports	state/descriptormanager.hpp	/^    std::vector<const DescriptorSetLayoutReport*> descriptorSetLayoutReports;$/;"	m	class:sword::state::final
descriptorSetLayouts	render/renderer.hpp	/^    std::unordered_map<std::string, vk::DescriptorSetLayout> descriptorSetLayouts;$/;"	m	class:sword::render::Renderer
descriptorSetLayouts	state/report.hpp	/^    std::vector<std::string> descriptorSetLayouts;$/;"	m	class:sword::state::PipelineLayoutReport
descriptorSetReports	state/descriptormanager.hpp	/^    Reports<DescriptorSetReport> descriptorSetReports; \/\/ownding$/;"	m	class:sword::state::final
descriptorSets	render/renderer.hpp	/^    std::vector<vk::DescriptorSet> descriptorSets;$/;"	m	class:sword::render::Renderer
descriptorSets	render/renderframe.hpp	/^    std::vector<vk::DescriptorSet> descriptorSets;$/;"	m	class:sword::render::RenderFrame
destroyDebugMessenger	render/context.cpp	/^void Context::destroyDebugMessenger()$/;"	f	class:sword::render::Context
destroyImageViews	render/swapchain.cpp	/^void Swapchain::destroyImageViews()$/;"	f	class:sword::render::Swapchain
devProps	render/resource.hpp	/^    const vk::PhysicalDeviceProperties& devProps;$/;"	m	class:sword::render::final
device	render/attachment.hpp	/^    const vk::Device& device;$/;"	m	class:sword::render::Attachment
device	render/context.hpp	/^    vk::UniqueDevice device;$/;"	m	class:sword::render::Context
device	render/pipeline.hpp	/^    const vk::Device& device;$/;"	m	class:sword::render::GraphicsPipeline
device	render/renderer.hpp	/^    const vk::Device& device;$/;"	m	class:sword::render::Renderer
device	render/renderframe.hpp	/^    const vk::Device& device;$/;"	m	class:sword::render::RenderFrame
device	render/renderlayer.hpp	/^    const vk::Device& device;$/;"	m	class:sword::render::RenderLayer
device	render/renderpass.hpp	/^    const vk::Device& device;$/;"	m	class:sword::render::RenderPass
device	render/resource.hpp	/^    const vk::Device& device;$/;"	m	class:sword::render::final
device	render/shader.hpp	/^    const vk::Device& device;$/;"	m	class:sword::render::Shader
device	render/types.hpp	/^    const vk::Device& device;$/;"	m	struct:sword::render::BufferResources
deviceExtensionProperties	render/context.hpp	/^    std::vector<vk::ExtensionProperties> deviceExtensionProperties;$/;"	m	class:sword::render::Context
deviceReport	render/context.cpp	/^void Context::deviceReport()$/;"	f	class:sword::render::Context
deviceSize	render/resource.hpp	/^    vk::DeviceSize deviceSize;$/;"	m	class:sword::render::final
dirState	application.hpp	/^    state::Director dirState;$/;"	m	class:sword::Application
dispatcher	application.hpp	/^    event::EventDispatcher dispatcher;$/;"	m	class:sword::Application
dispatcher	render/context.hpp	/^    vk::DispatchLoaderDynamic dispatcher;$/;"	m	class:sword::render::Context
displayCanvas	state/painter.cpp	/^void Painter::displayCanvas()$/;"	f	class:sword::state::painter::Input::Painter	file:
drawVerts	render/command.cpp	/^void CommandBuffer::drawVerts(uint32_t vertCount, uint32_t firstVertex)$/;"	f	class:sword::render::CommandBuffer
editStack	state/state.hpp	/^    EditStack& editStack;$/;"	m	class:sword::state::BranchState
editStack	state/state.hpp	/^    EditStack& editStack;$/;"	m	class:sword::state::LeafState
emplace_back	types/stack.hpp	/^    void emplace_back(T&& t) { items.emplace_back(std::move(t));}$/;"	f	class:sword::Stack
empty	types/stack.hpp	/^    bool empty() const {return items.empty();}$/;"	f	class:sword::Stack
end	render/command.cpp	/^void CommandBuffer::end()$/;"	f	class:sword::render::CommandBuffer
end	state/editstack.hpp	/^    auto end() const { return stack.end(); }$/;"	f	class:sword::state::EditStack
end	types/map.hpp	/^    auto end()$/;"	f	class:sword::SmallMap
end	types/stack.hpp	/^    auto end() const {return this->items.rend();}$/;"	f	class:sword::ReverseStack
end	types/stack.hpp	/^    auto end() {return this->items.end();}$/;"	f	class:sword::ForwardStack
end	util.hpp	/^void Timer::end(const std::string& funcName)$/;"	f	class:sword::Timer
endRenderPass	render/command.cpp	/^void CommandBuffer::endRenderPass()$/;"	f	class:sword::render::CommandBuffer
endTime	util.hpp	/^    std::chrono::time_point<std::chrono::high_resolution_clock> startTime, endTime;$/;"	m	class:sword::Timer
es	state/state.hpp	/^    EditStack& es;$/;"	m	struct:sword::state::StateArgs
event	event/dispatcher.cpp	/^namespace event$/;"	n	namespace:sword	file:
event	event/dispatcher.hpp	/^namespace event$/;"	n	namespace:sword
event	event/event.cpp	/^namespace event$/;"	n	namespace:sword	file:
event	event/event.hpp	/^namespace event$/;"	n	namespace:sword
event	event/filewatcher.cpp	/^namespace event$/;"	n	namespace:sword	file:
event	event/filewatcher.hpp	/^namespace event$/;"	n	namespace:sword
event	event/types.hpp	/^namespace event$/;"	n	namespace:sword
event	event/watcher.hpp	/^namespace event$/;"	n	namespace:sword
event	render/surface/window.hpp	/^	xcb_generic_event_t* event;$/;"	m	class:sword::render::Window
eventPool	event/filewatcher.hpp	/^    EventPool<File, 3> eventPool;$/;"	m	class:sword::event::FileWatcher
eventQueue	event/dispatcher.hpp	/^    EventQueue eventQueue;$/;"	m	class:sword::event::EventDispatcher
eventQueue	event/filewatcher.hpp	/^    EventQueue& eventQueue;$/;"	m	class:sword::event::FileWatcher
eventType	event/event.hpp	/^    WindowEventType eventType;$/;"	m	struct:sword::event::symbol::WindowInput
execute	command/rendercommands.cpp	/^void AddAttachment::execute(Application* app)$/;"	f	class:sword::command::AddAttachment
execute	command/rendercommands.cpp	/^void BindUboData::execute(Application* app)$/;"	f	class:sword::command::BindUboData
execute	command/rendercommands.cpp	/^void CreateDescriptorSetLayout::execute(Application* app)$/;"	f	class:sword::command::CreateDescriptorSetLayout
execute	command/rendercommands.cpp	/^void CreateFrameDescriptorSets::execute(Application* app)$/;"	f	class:sword::command::CreateFrameDescriptorSets
execute	command/rendercommands.cpp	/^void CreateGraphicsPipeline::execute(Application* app)$/;"	f	class:sword::command::CreateGraphicsPipeline
execute	command/rendercommands.cpp	/^void CreateOffscreenRenderpass::execute(Application* app)$/;"	f	class:sword::command::CreateOffscreenRenderpass
execute	command/rendercommands.cpp	/^void CreatePipelineLayout::execute(Application* app)$/;"	f	class:sword::command::CreatePipelineLayout
execute	command/rendercommands.cpp	/^void CreateRenderLayer::execute(Application* app)$/;"	f	class:sword::command::CreateRenderLayer
execute	command/rendercommands.cpp	/^void CreateSwapchainRenderpass::execute(Application* app)$/;"	f	class:sword::command::CreateSwapchainRenderpass
execute	command/rendercommands.cpp	/^void InitFrameUbos::execute(Application* app)$/;"	f	class:sword::command::InitFrameUbos
execute	command/rendercommands.cpp	/^void LoadFragShader::execute(Application* app)$/;"	f	class:sword::command::LoadFragShader
execute	command/rendercommands.cpp	/^void LoadVertShader::execute(Application* app)$/;"	f	class:sword::command::LoadVertShader
execute	command/rendercommands.cpp	/^void OpenWindow::execute(Application* app)$/;"	f	class:sword::command::OpenWindow
execute	command/rendercommands.cpp	/^void PrepareRenderFrames::execute(Application* app)$/;"	f	class:sword::command::PrepareRenderFrames
execute	command/rendercommands.cpp	/^void RecordRenderCommand::execute(Application* app)$/;"	f	class:sword::command::RecordRenderCommand
execute	command/rendercommands.cpp	/^void Render::execute(Application* app)$/;"	f	class:sword::command::Render
execute	command/rendercommands.cpp	/^void SetSpecFloat::execute(Application* app)$/;"	f	class:sword::command::SetSpecFloat
execute	command/rendercommands.cpp	/^void SetSpecInt::execute(Application* app)$/;"	f	class:sword::command::SetSpecInt
execute	command/rendercommands.cpp	/^void UpdateFrameSamplers::execute(Application* app)$/;"	f	class:sword::command::UpdateFrameSamplers
execute	command/saveimage.cpp	/^void CopyAttachmentToUndoStack::execute(Application* app)$/;"	f	class:sword::command::CopyAttachmentToUndoStack
execute	command/saveimage.cpp	/^void SaveAttachmentToPng::execute(Application* app)$/;"	f	class:sword::command::SaveAttachmentToPng
execute	command/saveimage.cpp	/^void SaveSwapToPng::execute(Application* app)$/;"	f	class:sword::command::SaveSwapToPng
execute	command/shader.cpp	/^void CompileShader::execute(Application* app)$/;"	f	class:sword::command::CompileShader
execute	command/shader.cpp	/^void CompileShaderCode::execute(Application* app)$/;"	f	class:sword::command::CompileShaderCode
execute	command/transfer.cpp	/^void CopyAttachmentToDevice::execute(Application* app)$/;"	f	class:sword::command::CopyAttachmentToDevice
execute	command/vocab.cpp	/^void AddVocab::execute(Application* app)$/;"	f	class:sword::command::AddVocab
execute	command/vocab.cpp	/^void PopVocab::execute(Application* app)$/;"	f	class:sword::command::PopVocab
execute	command/vocab.cpp	/^void SetVocab::execute(Application* app)$/;"	f	class:sword::command::SetVocab
execute	command/vocab.cpp	/^void UpdateVocab::execute(Application* app)$/;"	f	class:sword::command::UpdateVocab
execute	command/watcher.cpp	/^void WatchFile::execute(Application* app) $/;"	f	class:sword::command::WatchFile
extent	render/attachment.hpp	/^    vk::Extent2D extent;$/;"	m	class:sword::render::Attachment
extent	render/resource.hpp	/^    vk::Extent3D extent;$/;"	m	class:sword::render::final
extent	render/swapchain.hpp	/^	vk::Extent2D extent;$/;"	m	class:sword::render::Swapchain
extractCommand	state/state.cpp	/^Optional BranchState::extractCommand(event::Event* event)$/;"	f	class:sword::state::BranchState
extractShaderStageInfos	render/pipeline.cpp	/^std::vector<vk::PipelineShaderStageCreateInfo> GraphicsPipeline::extractShaderStageInfos()$/;"	f	class:sword::render::GraphicsPipeline
familyIndex	render/context.hpp	/^    int familyIndex;$/;"	m	struct:sword::render::QueueInfo
fd	event/filewatcher.hpp	/^    int fd;$/;"	m	class:sword::event::FileWatcher
fence	render/renderframe.hpp	/^    vk::Fence fence;$/;"	m	class:sword::render::RenderFrame
fetchCommandLineInput	event/dispatcher.cpp	/^void EventDispatcher::fetchCommandLineInput()$/;"	f	class:sword::event::EventDispatcher
fetchWindowInput	event/dispatcher.cpp	/^void EventDispatcher::fetchWindowInput()$/;"	f	class:sword::event::EventDispatcher
fileName	command/saveimage.hpp	/^    std::string fileName;$/;"	m	class:sword::command::SaveAttachmentToPng
fileName	command/saveimage.hpp	/^    std::string fileName;$/;"	m	class:sword::command::SaveSwapToPng
fileWatcher	event/dispatcher.hpp	/^    FileWatcher fileWatcher;$/;"	m	class:sword::event::EventDispatcher
file_finder	command/shader.hpp	/^    shaderc_util::FileFinder file_finder;$/;"	m	class:sword::command::CompileShader
filename	event/filewatcher.hpp	/^    std::string filename;$/;"	m	struct:sword::event::WatchTicket
final	event/event.hpp	/^class KeyPress final : public Keyboard$/;"	c	namespace:sword::event::symbol
final	event/event.hpp	/^class KeyRelease final : public Keyboard$/;"	c	namespace:sword::event::symbol
final	event/event.hpp	/^class MouseMotion final : public Window$/;"	c	namespace:sword::event::symbol
final	event/event.hpp	/^class MousePress final : public MouseButton$/;"	c	namespace:sword::event::symbol
final	event/event.hpp	/^class MouseRelease final : public MouseButton$/;"	c	namespace:sword::event::symbol
final	render/resource.hpp	/^class Buffer final$/;"	c	namespace:sword::render
final	render/resource.hpp	/^class Image final$/;"	c	namespace:sword::render
final	state/descriptormanager.hpp	/^class DescriptorManager final : public BranchState$/;"	c	namespace:sword::state
final	state/descriptorsetlayoutmanager.hpp	/^class DescriptorSetLayoutManager final : public BranchState$/;"	c	namespace:sword::state
final	state/director.hpp	/^class Director final : public BranchState$/;"	c	namespace:sword::state
final	state/painter.hpp	/^class Painter final : public BranchState$/;"	c	namespace:sword::state::painter
final	state/pipelinemanager.hpp	/^class CreatePipelineLayout final : public LeafState$/;"	c	namespace:sword::state
final	state/pipelinemanager.hpp	/^class PipelineManager final : public BranchState$/;"	c	namespace:sword::state
final	state/rendermanager.hpp	/^class RenderManager final : public BranchState$/;"	c	namespace:sword::state
final	state/renderpassmanager.hpp	/^class RenderPassManager final : public BranchState$/;"	c	namespace:sword::state
final	state/report.hpp	/^class ShaderReport final : public Report$/;"	c	namespace:sword::state
final	state/shader.hpp	/^class ShaderManager final : public BranchState$/;"	c	namespace:sword::state
final	state/state.hpp	/^    void onEnterImp() override final;$/;"	m	class:sword::state::LeafState
final	state/state.hpp	/^    void onExitImp() override final;$/;"	m	class:sword::state::LeafState
findElement	types/map.hpp	/^    std::optional<Element> findElement(const S& s, const T& t)$/;"	f	class:sword::SmallMap
findMemoryType	render/resource.cpp	/^uint32_t findMemoryType($/;"	f	namespace:sword::render
findOption	state/state.hpp	/^    std::optional<Option> findOption(const std::string& s, OptionMask mask) const$/;"	f	class:sword::state::OptionMap
findReport	state/state.hpp	/^    R* findReport(const std::string& name, const std::vector<std::unique_ptr<R>>& reports)$/;"	f	class:sword::state::LeafState
findValue	types/map.hpp	/^    std::optional<T> findValue(const S& s) const $/;"	f	class:sword::SmallMap
findValue	types/map.hpp	/^    std::optional<T> findValue(const S& s, std::bitset<N> mask) const $/;"	f	class:sword::SmallMap
flags	render/context.hpp	/^    vk::QueueFlags flags;$/;"	m	struct:sword::render::QueueInfo
format	render/attachment.hpp	/^    vk::Format format;$/;"	m	class:sword::render::Attachment
format	render/resource.hpp	/^    vk::Format format;$/;"	m	class:sword::render::final
frag	state/shader.hpp	/^    constexpr const char* frag = SWORD"\/src\/shaders\/fragment";$/;"	m	namespace:sword::state::shader_dir
frag	util/enum.hpp	/^enum class ShaderType : uint8_t {frag, vert};$/;"	m	class:sword::ShaderType
fragInput	state/painter.hpp	/^    FragmentInput fragInput;$/;"	m	struct:sword::state::painter::PainterVars
fragShaderAt	render/renderer.cpp	/^FragShader& Renderer::fragShaderAt(const std::string name)$/;"	f	class:sword::render::Renderer
frag_dir	state/shader.hpp	/^    static constexpr const char* frag_dir = shader_dir::frag;$/;"	m	class:sword::state::LoadFragShaders
fragmentShaders	render/renderer.hpp	/^    std::unordered_map<std::string, FragShader> fragmentShaders;$/;"	m	class:sword::render::Renderer
frameOwned	state/report.hpp	/^    enum class Type : uint8_t {frameOwned, rendererOwned};$/;"	m	class:sword::state::DescriptorSetReport::Type
framebuffer	render/renderlayer.hpp	/^    vk::Framebuffer framebuffer;$/;"	m	class:sword::render::RenderLayer
frames	render/renderer.hpp	/^    std::vector<RenderFrame> frames;$/;"	m	class:sword::render::Renderer
fullPath	command/saveimage.hpp	/^    bool fullPath;$/;"	m	class:sword::command::SaveAttachmentToPng
fullpath	event/filewatcher.hpp	/^    const char* fullpath;$/;"	m	struct:sword::event::WatchTicket
getArg	event/event.hpp	/^    T getArg()$/;"	f	class:sword::event::symbol::CommandLine
getAttachmentName	state/report.hpp	/^    const std::string_view getAttachmentName() { return attachmentName; }$/;"	f	class:sword::state::RenderLayerReport
getAttachmentPtr	render/renderer.cpp	/^const Attachment* Renderer::getAttachmentPtr(std::string name) const$/;"	f	class:sword::render::Renderer
getBufferResources	render/context.cpp	/^BufferResources Context::getBufferResources() const$/;"	f	class:sword::render::Context
getClearValue	render/renderpass.cpp	/^const vk::ClearValue* RenderPass::getClearValue() const$/;"	f	class:sword::render::RenderPass
getCmdIndex	state/report.hpp	/^    constexpr int getCmdIndex() const { return cmdIndex; }$/;"	f	class:sword::state::RenderCommandReport
getCurrentIndex	render/swapchain.cpp	/^uint8_t Swapchain::getCurrentIndex() const$/;"	f	class:sword::render::Swapchain
getDescriptorSets	render/renderframe.cpp	/^const std::vector<vk::DescriptorSet>& RenderFrame::getDescriptorSets() const$/;"	f	class:sword::render::RenderFrame
getDescriptorType	state/report.hpp	/^    inline std::string getDescriptorType(int index) $/;"	f	class:sword::state::DescriptorSetLayoutReport
getDevice	render/context.cpp	/^const vk::Device& Context::getDevice() const$/;"	f	class:sword::render::Context
getExtent	render/attachment.cpp	/^vk::Extent2D Attachment::getExtent() const$/;"	f	class:sword::render::Attachment
getExtent2D	render/resource.cpp	/^const vk::Extent2D Image::getExtent2D() const $/;"	f	class:sword::render::Image
getExtent2D	render/swapchain.cpp	/^vk::Extent2D Swapchain::getExtent2D()$/;"	f	class:sword::render::Swapchain
getExtent3D	render/swapchain.cpp	/^vk::Extent3D Swapchain::getExtent3D()$/;"	f	class:sword::render::Swapchain
getFence	render/command.cpp	/^const vk::Fence& CommandBuffer::getFence()$/;"	f	class:sword::render::CommandBuffer
getFirst	event/event.hpp	/^    T getFirst() const$/;"	f	class:sword::event::symbol::CommandLine
getFirstWord	event/event.hpp	/^    std::string getFirstWord() const $/;"	f	class:sword::event::symbol::CommandLine
getFormat	render/attachment.cpp	/^vk::Format Attachment::getFormat() const$/;"	f	class:sword::render::Attachment
getFormat	render/swapchain.cpp	/^vk::Format Swapchain::getFormat()$/;"	f	class:sword::render::Swapchain
getFragShader	state/report.hpp	/^    const std::string_view getFragShader() const { return fragshader; }$/;"	f	class:sword::state::GraphicsPipelineReport
getFramebuffer	render/renderlayer.cpp	/^const vk::Framebuffer& RenderLayer::getFramebuffer() const$/;"	f	class:sword::render::RenderLayer
getGraphicQueue	render/context.cpp	/^vk::Queue Context::getGraphicQueue(int index) const$/;"	f	class:sword::render::Context
getGraphicsQueueFamilyIndex	render/context.cpp	/^uint32_t Context::getGraphicsQueueFamilyIndex() const$/;"	f	class:sword::render::Context
getHandle	render/pipeline.cpp	/^const vk::Pipeline& GraphicsPipeline::getHandle() const$/;"	f	class:sword::render::GraphicsPipeline
getHandle	render/renderpass.cpp	/^const vk::RenderPass& RenderPass::getHandle() const$/;"	f	class:sword::render::RenderPass
getHandle	render/resource.cpp	/^vk::Buffer& Buffer::getHandle()$/;"	f	class:sword::render::Buffer
getHandle	render/swapchain.cpp	/^const vk::SwapchainKHR& Swapchain::getHandle() const$/;"	f	class:sword::render::Swapchain
getHeight	render/surface/window.hpp	/^    uint16_t getHeight() {return height;}$/;"	f	class:sword::render::Window
getId	state/report.hpp	/^    constexpr int getId() { return id; }$/;"	f	class:sword::state::RenderLayerReport
getImage	render/attachment.cpp	/^Image& Attachment::getImage(uint32_t index)$/;"	f	class:sword::render::Attachment
getImage	render/resource.cpp	/^vk::Image& Image::getImage()$/;"	f	class:sword::render::Image
getImageCount	render/swapchain.cpp	/^uint8_t Swapchain::getImageCount() const$/;"	f	class:sword::render::Swapchain
getImages	render/swapchain.cpp	/^std::vector<vk::Image>& Swapchain::getImages()$/;"	f	class:sword::render::Swapchain
getInput	event/event.hpp	/^    std::string getInput() const {return input;}$/;"	f	class:sword::event::symbol::CommandLine
getInstance	render/context.cpp	/^const vk::Instance& Context::getInstance() const$/;"	f	class:sword::render::Context
getKey	event/event.hpp	/^    symbol::Key getKey() const {return key;}$/;"	f	class:sword::event::symbol::Keyboard
getKeys	types/map.hpp	/^    std::vector<S> getKeys() const$/;"	f	class:sword::SmallMap
getKeys	types/map.hpp	/^    std::vector<S> getKeys(std::bitset<N> mask) const$/;"	f	class:sword::SmallMap
getLayout	render/pipeline.cpp	/^const vk::PipelineLayout& GraphicsPipeline::getLayout() const$/;"	f	class:sword::render::GraphicsPipeline
getMouseButton	event/event.hpp	/^    symbol::MouseButton getMouseButton() const {return button;}$/;"	f	class:sword::event::symbol::MouseButton
getObjectName	state/report.hpp	/^    const std::string getObjectName() const {return name;}$/;"	f	class:sword::state::PipelineLayoutReport
getPath	event/event.hpp	/^    std::string getPath() const { return path; }$/;"	f	class:sword::event::symbol::File
getPaths	util/file.cpp	/^const std::vector<std::string> getPaths(std::string_view root, bool inc_ext)$/;"	f	namespace:sword
getPhysicalDevice	render/context.cpp	/^const vk::PhysicalDevice& Context::getPhysicalDevice() const$/;"	f	class:sword::render::Context
getPipeline	render/renderlayer.cpp	/^const GraphicsPipeline& RenderLayer::getPipeline() const$/;"	f	class:sword::render::RenderLayer
getPipelineName	state/report.hpp	/^    const std::string_view getPipelineName() { return pipelineName; }$/;"	f	class:sword::state::RenderLayerReport
getRendePassName	state/report.hpp	/^    const std::string_view getRendePassName() { return renderpassName; }$/;"	f	class:sword::state::RenderLayerReport
getRenderArea	render/pipeline.cpp	/^vk::Rect2D GraphicsPipeline::getRenderArea() const$/;"	f	class:sword::render::GraphicsPipeline
getRenderBuffer	render/renderframe.cpp	/^CommandBuffer& RenderFrame::getRenderBuffer(uint32_t bufferId)$/;"	f	class:sword::render::RenderFrame
getRenderLayer	render/renderframe.hpp	/^    RenderLayer& getRenderLayer(int id) { return renderLayers.at(id);}$/;"	f	class:sword::render::RenderFrame
getRenderLayerIndices	state/report.hpp	/^    std::vector<uint32_t> getRenderLayerIndices() const { return rpiIndices; }$/;"	f	class:sword::state::RenderCommandReport
getRenderPass	render/pipeline.cpp	/^const RenderPass& GraphicsPipeline::getRenderPass() const$/;"	f	class:sword::render::GraphicsPipeline
getRenderPass	render/renderlayer.cpp	/^const RenderPass& RenderLayer::getRenderPass() const$/;"	f	class:sword::render::RenderLayer
getSampler	render/resource.cpp	/^const vk::Sampler& Image::getSampler() const$/;"	f	class:sword::render::Image
getSourcePath	state/report.hpp	/^    const std::string_view getSourcePath() const {return source_path;}$/;"	f	class:sword::state::final
getStageInfo	render/shader.cpp	/^const vk::PipelineShaderStageCreateInfo& Shader::getStageInfo() const$/;"	f	class:sword::render::Shader
getStream	event/event.hpp	/^    std::stringstream getStream() const$/;"	f	class:sword::event::symbol::CommandLine
getStrings	state/state.hpp	/^    std::vector<std::string> getStrings()$/;"	f	class:sword::state::OptionMap
getSwapAttachment	render/renderframe.cpp	/^Attachment& RenderFrame::getSwapAttachment()$/;"	f	class:sword::render::RenderFrame
getSwapExtent	render/renderer.cpp	/^vk::Extent2D Renderer::getSwapExtent()$/;"	f	class:sword::render::Renderer
getTransferQueue	render/context.cpp	/^vk::Queue Context::getTransferQueue(int index) const$/;"	f	class:sword::render::Context
getTransferQueueFamilyIndex	render/context.hpp	/^    uint32_t getTransferQueueFamilyIndex() const { return transferQueueInfo->familyIndex; }$/;"	f	class:sword::render::Context
getType	state/report.hpp	/^    ReportType getType() const {return ReportType::PipelineLayout;}$/;"	f	class:sword::state::PipelineLayoutReport
getUsage	state/report.hpp	/^    ReportUsage getUsage() const {return usage;}$/;"	f	class:sword::state::Report
getUsageFlags	render/swapchain.cpp	/^vk::ImageUsageFlags Swapchain::getUsageFlags()$/;"	f	class:sword::render::Swapchain
getVertShader	state/report.hpp	/^    const std::string_view getVertShader() const { return vertshader; }$/;"	f	class:sword::state::GraphicsPipelineReport
getView	render/resource.cpp	/^const vk::ImageView& Image::getView() const$/;"	f	class:sword::render::Image
getVocab	state/state.cpp	/^std::vector<std::string> State::getVocab()$/;"	f	class:sword::state::State
getWd	event/event.hpp	/^    int getWd() const { return wd; }$/;"	f	class:sword::event::symbol::File
getWidth	render/surface/window.hpp	/^    uint16_t getWidth() {return width;}$/;"	f	class:sword::render::Window
getWords	state/vocab.hpp	/^    std::vector<std::string> getWords() const $/;"	f	class:sword::state::Vocab
getX	event/event.hpp	/^    inline int16_t getX() const {return xPos;}$/;"	f	class:sword::event::symbol::Window
getY	event/event.hpp	/^    inline int16_t getY() const {return yPos;}$/;"	f	class:sword::event::symbol::Window
glslCode	command/shader.hpp	/^    std::string glslCode;$/;"	m	class:sword::command::CompileShaderCode
gpuCommandPool	types/pool.hpp	/^    std::unique_ptr<render::CommandPool> gpuCommandPool;$/;"	m	class:sword::Pool
graphicsPipeReports	state/pipelinemanager.hpp	/^    Reports<GraphicsPipelineReport> graphicsPipeReports;$/;"	m	class:sword::state::final
graphicsPipelines	render/renderer.hpp	/^    std::unordered_map<std::string, GraphicsPipeline> graphicsPipelines;$/;"	m	class:sword::render::Renderer
graphicsQueue	render/renderer.hpp	/^    const vk::Queue graphicsQueue;$/;"	m	class:sword::render::Renderer
graphicsQueueInfo	render/context.hpp	/^    std::optional<QueueInfo> graphicsQueueInfo;$/;"	m	class:sword::render::Context
grow	types/region.hpp	/^    void grow()$/;"	f	class:sword::Region
handle	render/pipeline.hpp	/^    vk::Pipeline handle;$/;"	m	class:sword::render::GraphicsPipeline
handle	render/resource.hpp	/^    vk::Buffer handle;$/;"	m	class:sword::render::final
handle	render/resource.hpp	/^    vk::Image handle;$/;"	m	class:sword::render::final
handleEvent	state/descriptormanager.cpp	/^void CreateFrameDescriptorSets::handleEvent(event::Event* event)$/;"	f	class:sword::state::CreateFrameDescriptorSets
handleEvent	state/descriptormanager.cpp	/^void DescriptorManager::handleEvent(event::Event* event)$/;"	f	class:sword::state::DescriptorManager
handleEvent	state/descriptormanager.cpp	/^void InitFrameUbos::handleEvent(event::Event* event)$/;"	f	class:sword::state::InitFrameUbos
handleEvent	state/descriptormanager.cpp	/^void UpdateFrameSamplers::handleEvent(event::Event* event)$/;"	f	class:sword::state::UpdateFrameSamplers
handleEvent	state/descriptorsetlayoutmanager.cpp	/^void CreateDescriptorSetLayout::handleEvent(event::Event* event)$/;"	f	class:sword::state::CreateDescriptorSetLayout
handleEvent	state/descriptorsetlayoutmanager.cpp	/^void DescriptorSetLayoutManager::handleEvent(event::Event* event)$/;"	f	class:sword::state::DescriptorSetLayoutManager
handleEvent	state/descriptorsetlayoutmanager.cpp	/^void SetDescriptorCount::handleEvent(event::Event* event)$/;"	f	class:sword::state::SetDescriptorCount
handleEvent	state/descriptorsetlayoutmanager.cpp	/^void SetShaderStageEntry::handleEvent(event::Event* event)$/;"	f	class:sword::state::SetShaderStageEntry
handleEvent	state/descriptorsetlayoutmanager.cpp	/^void SetStateType::handleEvent(event::Event* event)$/;"	f	class:sword::state::SetStateType
handleEvent	state/director.cpp	/^void Director::handleEvent(event::Event* event)$/;"	f	class:sword::state::Director
handleEvent	state/painter.cpp	/^void Paint::handleEvent(event::Event* event)$/;"	f	class:sword::state::painter::Input::Paint	file:
handleEvent	state/painter.cpp	/^void Painter::handleEvent(event::Event* event)$/;"	f	class:sword::state::painter::Input::Painter	file:
handleEvent	state/painter.cpp	/^void ResizeBrush::handleEvent(event::Event* event)$/;"	f	class:sword::state::painter::Input::ResizeBrush	file:
handleEvent	state/painter.cpp	/^void Rotate::handleEvent(event::Event *event)$/;"	f	class:sword::state::painter::Input::Rotate	file:
handleEvent	state/painter.cpp	/^void SaveAttachment::handleEvent(event::Event* event)$/;"	f	class:sword::state::painter::Input::SaveAttachment	file:
handleEvent	state/painter.cpp	/^void SaveSwap::handleEvent(event::Event* event)$/;"	f	class:sword::state::painter::Input::SaveSwap	file:
handleEvent	state/painter.cpp	/^void Scale::handleEvent(event::Event *event)$/;"	f	class:sword::state::painter::Input::Scale	file:
handleEvent	state/painter.cpp	/^void Translate::handleEvent(event::Event *event)$/;"	f	class:sword::state::painter::Input::Translate	file:
handleEvent	state/pipelinemanager.cpp	/^void CreateGraphicsPipeline::handleEvent(event::Event* event)$/;"	f	class:sword::state::CreateGraphicsPipeline
handleEvent	state/pipelinemanager.cpp	/^void CreatePipelineLayout::handleEvent(event::Event* event)$/;"	f	class:sword::state::CreatePipelineLayout
handleEvent	state/pipelinemanager.cpp	/^void PipelineManager::handleEvent(event::Event* event)$/;"	f	class:sword::state::PipelineManager
handleEvent	state/rendermanager.cpp	/^void CreateRenderLayer::handleEvent(event::Event* event)$/;"	f	class:sword::state::CreateRenderLayer
handleEvent	state/rendermanager.cpp	/^void RecordRenderCommand::handleEvent(event::Event* event)$/;"	f	class:sword::state::RecordRenderCommand
handleEvent	state/rendermanager.cpp	/^void Render::handleEvent(event::Event* event)$/;"	f	class:sword::state::Render
handleEvent	state/rendermanager.cpp	/^void RenderManager::handleEvent(event::Event* event)$/;"	f	class:sword::state::RenderManager
handleEvent	state/rendermanager.cpp	/^void SaveSwapImage::handleEvent(event::Event* event)$/;"	f	class:sword::state::SaveSwapImage
handleEvent	state/renderpassmanager.cpp	/^void CreateRenderPass::handleEvent(event::Event* event)$/;"	f	class:sword::state::CreateRenderPass
handleEvent	state/renderpassmanager.cpp	/^void RenderPassManager::handleEvent(event::Event* event)$/;"	f	class:sword::state::RenderPassManager
handleEvent	state/shader.cpp	/^void CompileShader::handleEvent(event::Event* event)$/;"	f	class:sword::state::CompileShader
handleEvent	state/shader.cpp	/^void LoadFragShaders::handleEvent(event::Event* event)$/;"	f	class:sword::state::LoadFragShaders
handleEvent	state/shader.cpp	/^void LoadVertShaders::handleEvent(event::Event* event)$/;"	f	class:sword::state::LoadVertShaders
handleEvent	state/shader.cpp	/^void PrintShader::handleEvent(event::Event* event)$/;"	f	class:sword::state::PrintShader
handleEvent	state/shader.cpp	/^void SetSpec::handleEvent(event::Event* event)$/;"	f	class:sword::state::SetSpec
handleEvent	state/shader.cpp	/^void ShaderManager::handleEvent(event::Event* event)$/;"	f	class:sword::state::ShaderManager
handleEvent	state/shader.cpp	/^void WatchFile::handleEvent(event::Event* event)$/;"	f	class:sword::state::WatchFile
handleShaderReport	state/pipelinemanager.cpp	/^void PipelineManager::handleShaderReport(const ShaderReport* report)$/;"	f	class:sword::state::PipelineManager
hasCreatedLayout	state/descriptorsetlayoutmanager.cpp	/^bool DescriptorSetLayoutManager::hasCreatedLayout()$/;"	f	class:sword::state::DescriptorSetLayoutManager
heapPtr	types/heap.hpp	/^    void* heapPtr;$/;"	m	class:sword::Heap
height	render/renderframe.hpp	/^    uint32_t height;$/;"	m	class:sword::render::RenderFrame
height	render/surface/window.hpp	/^    uint16_t width, height;$/;"	m	class:sword::render::Window
height	state/report.hpp	/^    const int width, height;$/;"	m	class:sword::state::AttachmentReport
hostBuffer	render/renderer.hpp	/^    std::unique_ptr<Buffer> hostBuffer;$/;"	m	class:sword::render::Renderer
id	state/report.hpp	/^    int id;$/;"	m	class:sword::state::RenderLayerReport
imageAcquiredSemaphore	render/renderer.hpp	/^    vk::Semaphore imageAcquiredSemaphore;$/;"	m	class:sword::render::Renderer
imageCount	render/swapchain.hpp	/^	uint8_t imageCount;$/;"	m	class:sword::render::Swapchain
imagePtrs	command/rendercommands.hpp	/^    std::vector<const vk::Image*> imagePtrs;$/;"	m	class:sword::command::UpdateFrameSamplers
imageViews	render/swapchain.hpp	/^	std::vector<vk::ImageView> imageViews;$/;"	m	class:sword::render::Swapchain
images	render/attachment.hpp	/^    std::vector<std::unique_ptr<Image>> images;$/;"	m	class:sword::render::Attachment
images	render/swapchain.hpp	/^	std::vector<vk::Image> images;$/;"	m	class:sword::render::Swapchain
initBasic	state/painter.cpp	/^void Painter::initBasic()$/;"	f	class:sword::state::painter::Input::Painter	file:
initBasic	state/painter.hpp	/^    enum class Op : Option {initBasic, paint, brushResize, saveAttachmentToPng};$/;"	m	class:sword::state::painter::final::Op
initFrameUBOs	render/renderer.cpp	/^void Renderer::initFrameUBOs(size_t size, uint32_t binding)$/;"	f	class:sword::render::Renderer
initFrameUBOs	state/descriptormanager.hpp	/^    enum class Op : Option {createFrameDescriptorSets, printReports, descriptorSetLayoutMgr, initFrameUBOs, updateFrameSamplers};$/;"	m	class:sword::state::final::Op
initFrameUbos	command/commandpools.hpp	/^    CommandPool<command::InitFrameUbos> initFrameUbos;$/;"	m	struct:sword::CommandPools
initFrameUbos	state/descriptormanager.hpp	/^    InitFrameUbos initFrameUbos;$/;"	m	class:sword::state::final
initX	state/painter.hpp	/^    float initX, initY;$/;"	m	class:sword::state::painter::Rotate
initX	state/painter.hpp	/^    float initX, initY;$/;"	m	class:sword::state::painter::Scale
initY	state/painter.hpp	/^    float initX, initY;$/;"	m	class:sword::state::painter::Rotate
initY	state/painter.hpp	/^    float initX, initY;$/;"	m	class:sword::state::painter::Scale
initialize	render/shader.cpp	/^void Shader::initialize()$/;"	f	class:sword::render::Shader
input	event/event.hpp	/^    std::string input;$/;"	m	class:sword::event::symbol::CommandLine
inputAssemblySate	render/pipeline.hpp	/^    vk::PipelineInputAssemblyStateCreateInfo inputAssemblySate;$/;"	m	class:sword::render::GraphicsPipeline
inputCast	state/painter.cpp	/^constexpr Input inputCast(event::symbol::Key key) { return static_cast<Input>(key); }$/;"	f	class:sword::state::painter::Input	file:
inputCast	state/painter.cpp	/^constexpr Input inputCast(event::symbol::MouseButton button) { return static_cast<Input>(button); }$/;"	f	class:sword::state::painter::Input	file:
insertImageMemoryBarrier	render/command.cpp	/^void CommandBuffer::insertImageMemoryBarrier($/;"	f	class:sword::render::CommandBuffer
instance	render/context.hpp	/^    vk::UniqueInstance instance;$/;"	m	class:sword::render::Context
integer	state/shader.hpp	/^    enum class SpecType : uint8_t {integer, floating};$/;"	m	class:sword::state::final::SpecType
integer	state/shader.hpp	/^    enum class SpecType : uint8_t {integer, floating};$/;"	m	class:sword::state::shader::SpecType
is	application.hpp	/^    std::ifstream is;$/;"	m	class:sword::Application
isAvailable	command/command.hpp	/^    constexpr bool isAvailable() const {return !inUse;}$/;"	f	class:sword::command::Command
isAvailable	event/event.hpp	/^    inline bool isAvailable() const {return !inUse;}$/;"	f	class:sword::event::symbol::Event
isCreated	render/pipeline.cpp	/^bool GraphicsPipeline::isCreated() const$/;"	f	class:sword::render::GraphicsPipeline
isCreated	render/renderpass.cpp	/^bool RenderPass::isCreated() const$/;"	f	class:sword::render::RenderPass
isHandled	event/event.hpp	/^    inline bool isHandled() const {return handled;}$/;"	f	class:sword::event::symbol::Event
isMapped	render/resource.hpp	/^    bool isMapped = false;$/;"	m	class:sword::render::final
isOpen	render/surface/window.hpp	/^    bool isOpen() {return opened;}$/;"	f	class:sword::render::Window
isRecorded	render/command.cpp	/^bool CommandBuffer::isRecorded() const$/;"	f	class:sword::render::CommandBuffer
itemSizes	types/region.hpp	/^    int itemSizes[max_item_count];$/;"	m	class:sword::Region
items	types/stack.hpp	/^    std::vector<T> items;$/;"	m	class:sword::Stack
key	event/event.hpp	/^    symbol::Key key;$/;"	m	class:sword::event::symbol::Keyboard
key	event/event.hpp	/^    symbol::Key key;$/;"	m	struct:sword::event::symbol::WindowInput
keyAt	types/map.hpp	/^    S keyAt(int i) const { return options.at(i).first; }$/;"	f	class:sword::SmallMap
kind	command/shader.hpp	/^    shaderc_shader_kind kind;$/;"	m	class:sword::command::CompileShader
kind	command/shader.hpp	/^    shaderc_shader_kind kind;$/;"	m	class:sword::command::CompileShaderCode
kpPool	event/dispatcher.hpp	/^    EventPool<KeyPress, 50> kpPool;$/;"	m	class:sword::event::EventDispatcher
krPool	event/dispatcher.hpp	/^    EventPool<KeyRelease, 20> krPool;$/;"	m	class:sword::event::EventDispatcher
layout	render/pipeline.hpp	/^    vk::PipelineLayout layout;$/;"	m	class:sword::render::GraphicsPipeline
layout	render/resource.hpp	/^    vk::ImageLayout layout;$/;"	m	class:sword::render::final
layoutnames	command/rendercommands.hpp	/^    std::vector<std::string> layoutnames;$/;"	m	class:sword::command::CreateFrameDescriptorSets
leaf	state/state.hpp	/^enum class StateType : uint8_t {leaf, branch, brief};$/;"	m	class:sword::state::StateType
lfPool	state/shader.hpp	/^    CommandPool<command::LoadFragShader>& lfPool;$/;"	m	class:sword::state::LoadFragShaders
listAttachments	render/renderer.cpp	/^void Renderer::listAttachments() const$/;"	f	class:sword::render::Renderer
listFragShaders	render/renderer.cpp	/^void Renderer::listFragShaders() const$/;"	f	class:sword::render::Renderer
listPipelineLayouts	render/renderer.cpp	/^void Renderer::listPipelineLayouts() const$/;"	f	class:sword::render::Renderer
listRenderPasses	render/renderer.cpp	/^void Renderer::listRenderPasses() const$/;"	f	class:sword::render::Renderer
listVertShaders	render/renderer.cpp	/^void Renderer::listVertShaders() const$/;"	f	class:sword::render::Renderer
loadFile	render/shader.cpp	/^void Shader::loadFile(std::string filepath)$/;"	f	class:sword::render::Shader
loadFrag	state/shader.hpp	/^    enum class Op : Option {watchFile, compileShader, printShader, loadFrag, loadVert, setSpecInt, setSpecFloat, printReports};$/;"	m	class:sword::state::final::Op
loadFragShader	command/commandpools.hpp	/^    CommandPool<command::LoadFragShader> loadFragShader;$/;"	m	struct:sword::CommandPools
loadFragShader	render/renderer.cpp	/^bool Renderer::loadFragShader($/;"	f	class:sword::render::Renderer
loadFragShaders	state/shader.hpp	/^    LoadFragShaders loadFragShaders;$/;"	m	class:sword::state::final
loadFragShaders	state/state.hpp	/^    const LoadFragShaders* loadFragShaders;$/;"	m	struct:sword::state::Register
loadOp	command/rendercommands.hpp	/^    vk::AttachmentLoadOp loadOp;$/;"	m	class:sword::command::CreateOffscreenRenderpass
loadOp	state/report.hpp	/^    vk::AttachmentLoadOp loadOp;$/;"	m	class:sword::state::RenderPassReport
loadVert	state/shader.hpp	/^    enum class Op : Option {watchFile, compileShader, printShader, loadFrag, loadVert, setSpecInt, setSpecFloat, printReports};$/;"	m	class:sword::state::final::Op
loadVertShader	command/commandpools.hpp	/^    CommandPool<command::LoadVertShader> loadVertShader;$/;"	m	struct:sword::CommandPools
loadVertShader	render/renderer.cpp	/^bool Renderer::loadVertShader($/;"	f	class:sword::render::Renderer
loadVertShaders	state/shader.hpp	/^    LoadVertShaders loadVertShaders;$/;"	m	class:sword::state::final
loadVertShaders	state/state.hpp	/^    const LoadVertShaders* loadVertShaders;$/;"	m	struct:sword::state::Register
lvPool	state/shader.hpp	/^    CommandPool<command::LoadVertShader>& lvPool;$/;"	m	class:sword::state::LoadVertShaders
lwPool	event/dispatcher.hpp	/^    EventPool<LeaveWindow, 3> lwPool;$/;"	m	class:sword::event::EventDispatcher
makeCreateInfo	render/context.hpp	/^    vk::DeviceQueueCreateInfo makeCreateInfo()$/;"	f	struct:sword::render::QueueInfo
makeHeader	util/stringutil.hpp	/^inline std::string makeHeader(const std::string text, const char e = '=')$/;"	f	namespace:sword::util
makeReport	command/command.hpp	/^    virtual state::Report* makeReport() const { return nullptr; };$/;"	f	class:sword::command::Command
makeReport	command/rendercommands.cpp	/^state::Report* CreateDescriptorSetLayout::makeReport() const$/;"	f	class:sword::command::CreateDescriptorSetLayout
makeReport	command/rendercommands.cpp	/^state::Report* CreateFrameDescriptorSets::makeReport() const$/;"	f	class:sword::command::CreateFrameDescriptorSets
makeReport	command/rendercommands.cpp	/^state::Report* CreateGraphicsPipeline::makeReport() const$/;"	f	class:sword::command::CreateGraphicsPipeline
makeReport	command/rendercommands.cpp	/^state::Report* CreateOffscreenRenderpass::makeReport() const$/;"	f	class:sword::command::CreateOffscreenRenderpass
makeReport	command/rendercommands.cpp	/^state::Report* CreatePipelineLayout::makeReport() const$/;"	f	class:sword::command::CreatePipelineLayout
makeReport	command/rendercommands.cpp	/^state::Report* CreateRenderLayer::makeReport() const$/;"	f	class:sword::command::CreateRenderLayer
makeReport	command/rendercommands.cpp	/^state::Report* CreateSwapchainRenderpass::makeReport() const$/;"	f	class:sword::command::CreateSwapchainRenderpass
makeReport	command/rendercommands.cpp	/^state::Report* LoadFragShader::makeReport() const$/;"	f	class:sword::command::LoadFragShader
makeReport	command/rendercommands.cpp	/^state::Report* LoadVertShader::makeReport() const$/;"	f	class:sword::command::LoadVertShader
makeReport	command/rendercommands.cpp	/^state::Report* RecordRenderCommand::makeReport() const$/;"	f	class:sword::command::RecordRenderCommand
makeReport	command/rendercommands.cpp	/^state::Report* SetSpecFloat::makeReport() const$/;"	f	class:sword::command::SetSpecFloat
makeReport	command/rendercommands.cpp	/^state::Report* SetSpecInt::makeReport() const$/;"	f	class:sword::command::SetSpecInt
makeReport	command/shader.cpp	/^state::Report* CompileShader::makeReport() const$/;"	f	class:sword::command::CompileShader
makeReport	command/shader.cpp	/^state::Report* CompileShaderCode::makeReport() const$/;"	f	class:sword::command::CompileShaderCode
makeReport	command/watcher.cpp	/^state::Report* WatchFile::makeReport() const$/;"	f	class:sword::command::WatchFile
map	render/resource.cpp	/^void Buffer::map()$/;"	f	class:sword::render::Buffer
map	state/state.hpp	/^    SmallMap<std::string, Option> map;$/;"	m	class:sword::state::OptionMap
mapEntries	render/shader.hpp	/^    std::vector<vk::SpecializationMapEntry> mapEntries;$/;"	m	class:sword::render::Shader
mask	render/surface/window.hpp	/^	uint32_t mask = 0;$/;"	m	class:sword::render::Window
matrices	state/painter.hpp	/^    Matrices matrices;$/;"	m	struct:sword::state::painter::PainterVars
max_item_count	types/region.hpp	/^    static constexpr int max_item_count = 10;$/;"	m	class:sword::Region
memProps	render/resource.hpp	/^    const vk::PhysicalDeviceMemoryProperties& memProps;$/;"	m	class:sword::render::final
memory	render/resource.hpp	/^    vk::DeviceMemory memory;$/;"	m	class:sword::render::final
memoryProperties	render/types.hpp	/^    const vk::PhysicalDeviceMemoryProperties& memoryProperties;$/;"	m	struct:sword::render::BufferResources
memoryTypeFlags	render/resource.hpp	/^    vk::MemoryPropertyFlags memoryTypeFlags;$/;"	m	class:sword::render::final
merge	state/report.hpp	/^    merge,$/;"	m	class:sword::state::ReportUsage
mmPool	event/dispatcher.hpp	/^    EventPool<MouseMotion, 100> mmPool;$/;"	m	class:sword::event::EventDispatcher
mouseButton	event/event.hpp	/^    symbol::MouseButton mouseButton;$/;"	m	struct:sword::event::symbol::WindowInput
mpPool	event/dispatcher.hpp	/^    EventPool<MousePress, 20> mpPool;$/;"	m	class:sword::event::EventDispatcher
mrPool	event/dispatcher.hpp	/^    EventPool<MouseRelease, 20> mrPool;$/;"	m	class:sword::event::EventDispatcher
multisampleState	render/pipeline.hpp	/^    vk::PipelineMultisampleStateCreateInfo multisampleState;$/;"	m	class:sword::render::GraphicsPipeline
name	command/shader.hpp	/^    std::string name;$/;"	m	class:sword::command::CompileShader
name	command/shader.hpp	/^    std::string name;$/;"	m	class:sword::command::CompileShaderCode
name	render/pipeline.hpp	/^    const std::string name;$/;"	m	class:sword::render::GraphicsPipeline
name	render/renderpass.hpp	/^    const std::string name;$/;"	m	class:sword::render::RenderPass
name	state/report.hpp	/^    const std::string name;$/;"	m	class:sword::state::AttachmentReport
name	state/report.hpp	/^    const std::string name;$/;"	m	class:sword::state::DescriptorSetLayoutReport
name	state/report.hpp	/^    std::string name;$/;"	m	class:sword::state::PipelineLayoutReport
normCoords	event/dispatcher.cpp	/^float normCoords(int16_t windowCoord, int16_t extent)$/;"	f	namespace:sword::event
null2	state/painter.hpp	/^    float null2;$/;"	m	struct:sword::state::painter::FragmentInput
offscreen	render/renderer.hpp	/^enum class TargetType {offscreen, swapchain};$/;"	m	class:sword::render::TargetType
offscreenDim	application.hpp	/^    vk::Extent2D offscreenDim;$/;"	m	class:sword::Application
onEnter	state/state.cpp	/^void State::onEnter()$/;"	f	class:sword::state::State
onEnterExt	state/descriptormanager.cpp	/^void CreateFrameDescriptorSets::onEnterExt()$/;"	f	class:sword::state::CreateFrameDescriptorSets
onEnterExt	state/descriptormanager.cpp	/^void InitFrameUbos::onEnterExt()$/;"	f	class:sword::state::InitFrameUbos
onEnterExt	state/descriptormanager.cpp	/^void UpdateFrameSamplers::onEnterExt()$/;"	f	class:sword::state::UpdateFrameSamplers
onEnterExt	state/descriptorsetlayoutmanager.cpp	/^void CreateDescriptorSetLayout::onEnterExt()$/;"	f	class:sword::state::CreateDescriptorSetLayout
onEnterExt	state/descriptorsetlayoutmanager.cpp	/^void SetDescriptorCount::onEnterExt()$/;"	f	class:sword::state::SetDescriptorCount
onEnterExt	state/descriptorsetlayoutmanager.cpp	/^void SetShaderStageEntry::onEnterExt()$/;"	f	class:sword::state::SetShaderStageEntry
onEnterExt	state/descriptorsetlayoutmanager.cpp	/^void SetStateType::onEnterExt()$/;"	f	class:sword::state::SetStateType
onEnterExt	state/director.cpp	/^void QuickSetup::onEnterExt()$/;"	f	class:sword::state::QuickSetup
onEnterExt	state/painter.cpp	/^void ResizeBrush::onEnterExt()$/;"	f	class:sword::state::painter::Input::ResizeBrush	file:
onEnterExt	state/painter.cpp	/^void Rotate::onEnterExt()$/;"	f	class:sword::state::painter::Input::Rotate	file:
onEnterExt	state/painter.cpp	/^void SaveAttachment::onEnterExt()$/;"	f	class:sword::state::painter::Input::SaveAttachment	file:
onEnterExt	state/painter.cpp	/^void SaveSwap::onEnterExt()$/;"	f	class:sword::state::painter::Input::SaveSwap	file:
onEnterExt	state/painter.cpp	/^void Scale::onEnterExt()$/;"	f	class:sword::state::painter::Input::Scale	file:
onEnterExt	state/painter.cpp	/^void Translate::onEnterExt()$/;"	f	class:sword::state::painter::Input::Translate	file:
onEnterExt	state/pipelinemanager.cpp	/^void CreateGraphicsPipeline::onEnterExt()$/;"	f	class:sword::state::CreateGraphicsPipeline
onEnterExt	state/pipelinemanager.cpp	/^void CreatePipelineLayout::onEnterExt()$/;"	f	class:sword::state::CreatePipelineLayout
onEnterExt	state/rendermanager.cpp	/^void CreateRenderLayer::onEnterExt()$/;"	f	class:sword::state::CreateRenderLayer
onEnterExt	state/rendermanager.cpp	/^void OpenWindow::onEnterExt()$/;"	f	class:sword::state::OpenWindow
onEnterExt	state/rendermanager.cpp	/^void PrepareRenderFrames::onEnterExt()$/;"	f	class:sword::state::PrepareRenderFrames
onEnterExt	state/rendermanager.cpp	/^void RecordRenderCommand::onEnterExt()$/;"	f	class:sword::state::RecordRenderCommand
onEnterExt	state/rendermanager.cpp	/^void Render::onEnterExt()$/;"	f	class:sword::state::Render
onEnterExt	state/rendermanager.cpp	/^void SaveSwapImage::onEnterExt()$/;"	f	class:sword::state::SaveSwapImage
onEnterExt	state/renderpassmanager.cpp	/^void CreateRenderPass::onEnterExt()$/;"	f	class:sword::state::CreateRenderPass
onEnterExt	state/shader.cpp	/^void CompileShader::onEnterExt()$/;"	f	class:sword::state::CompileShader
onEnterExt	state/shader.cpp	/^void LoadFragShaders::onEnterExt()$/;"	f	class:sword::state::LoadFragShaders
onEnterExt	state/shader.cpp	/^void LoadVertShaders::onEnterExt()$/;"	f	class:sword::state::LoadVertShaders
onEnterExt	state/shader.cpp	/^void PrintShader::onEnterExt()$/;"	f	class:sword::state::PrintShader
onEnterExt	state/shader.cpp	/^void SetSpec::onEnterExt()$/;"	f	class:sword::state::SetSpec
onEnterExt	state/shader.cpp	/^void WatchFile::onEnterExt()$/;"	f	class:sword::state::WatchFile
onEnterExt	state/state.hpp	/^    virtual void onEnterExt() {}$/;"	f	class:sword::state::State
onEnterImp	state/state.cpp	/^void LeafState::onEnterImp()$/;"	f	class:sword::state::LeafState
onEnterImp	state/state.cpp	/^void State::onEnterImp()$/;"	f	class:sword::state::State
onExit	state/state.cpp	/^void State::onExit()$/;"	f	class:sword::state::State
onExitExt	state/state.hpp	/^    virtual void onExitExt() {}$/;"	f	class:sword::state::State
onExitImp	state/state.cpp	/^void LeafState::onExitImp()$/;"	f	class:sword::state::LeafState
onExitImp	state/state.cpp	/^void State::onExitImp()$/;"	f	class:sword::state::State
onPrepRenderFrames	state/rendermanager.cpp	/^void RenderManager::onPrepRenderFrames()$/;"	f	class:sword::state::RenderManager
onSuccess	command/command.hpp	/^    void onSuccess() {$/;"	f	class:sword::command::Command
opcast	state/option.hpp	/^constexpr Option opcast(T op) {return static_cast<Option>(op);}$/;"	f	namespace:sword::state
opcast	state/option.hpp	/^constexpr T opcast(Option op) {return static_cast<T>(op);}$/;"	f	namespace:sword::state
open	render/surface/window.cpp	/^void Window::open()$/;"	f	class:sword::render::Window
openWindow	command/commandpools.hpp	/^    CommandPool<command::OpenWindow> openWindow;$/;"	m	struct:sword::CommandPools
openWindow	state/rendermanager.hpp	/^    OpenWindow openWindow;$/;"	m	class:sword::state::final
openWindow	state/rendermanager.hpp	/^    enum class Op : Option {saveSwapImage, printReports, render, openWindow, prepRenderFrames, shaderManager, $/;"	m	class:sword::state::final::Op
openWindow	state/state.hpp	/^    const OpenWindow* openWindow;$/;"	m	struct:sword::state::Register
operator ()	state/report.hpp	/^    void operator()() const $/;"	f	class:sword::state::PipelineLayoutReport
operator <	render/renderpass.cpp	/^bool RenderPass::operator<(const RenderPass& rhs)$/;"	f	class:sword::render::RenderPass
options	state/descriptorsetlayoutmanager.hpp	/^    SmallMap<std::string, vk::DescriptorType> options;$/;"	m	class:sword::state::SetStateType
options	state/descriptorsetlayoutmanager.hpp	/^    SmallMap<std::string, vk::ShaderStageFlagBits> options;$/;"	m	class:sword::state::SetShaderStageEntry
options	state/state.hpp	/^    OptionMap options;$/;"	m	class:sword::state::BranchState
options	types/map.hpp	/^    std::vector<Element> options;$/;"	m	class:sword::SmallMap
os	application.hpp	/^    std::ofstream os;$/;"	m	class:sword::Application
other	render/attachment.hpp	/^    Attachment& operator=(Attachment &&other) = delete;$/;"	m	class:sword::render::Attachment
other	render/attachment.hpp	/^    Attachment(Attachment&& other) = delete;$/;"	m	class:sword::render::Attachment
other	render/renderframe.hpp	/^    RenderFrame& operator=(RenderFrame&& other) = delete;$/;"	m	class:sword::render::RenderFrame
other	render/shader.hpp	/^    Shader& operator=(Shader& other) = delete; \/\/no copy assignment$/;"	m	class:sword::render::Shader
other	render/shader.hpp	/^    Shader& operator=(Shader&& other) = delete; \/\/no move assignment$/;"	m	class:sword::render::Shader
other	render/shader.hpp	/^    Shader(Shader&& other) = delete;$/;"	m	class:sword::render::Shader
override	command/rendercommands.hpp	/^    state::Report* makeReport() const override;$/;"	m	class:sword::command::CreateDescriptorSetLayout
override	command/rendercommands.hpp	/^    state::Report* makeReport() const override;$/;"	m	class:sword::command::CreateFrameDescriptorSets
override	command/rendercommands.hpp	/^    state::Report* makeReport() const override;$/;"	m	class:sword::command::CreateGraphicsPipeline
override	command/rendercommands.hpp	/^    state::Report* makeReport() const override;$/;"	m	class:sword::command::CreateOffscreenRenderpass
override	command/rendercommands.hpp	/^    state::Report* makeReport() const override;$/;"	m	class:sword::command::CreatePipelineLayout
override	command/rendercommands.hpp	/^    state::Report* makeReport() const override;$/;"	m	class:sword::command::CreateRenderLayer
override	command/rendercommands.hpp	/^    state::Report* makeReport() const override;$/;"	m	class:sword::command::CreateSwapchainRenderpass
override	command/rendercommands.hpp	/^    state::Report* makeReport() const override;$/;"	m	class:sword::command::LoadFragShader
override	command/rendercommands.hpp	/^    state::Report* makeReport() const override;$/;"	m	class:sword::command::LoadVertShader
override	command/rendercommands.hpp	/^    state::Report* makeReport() const override;$/;"	m	class:sword::command::RecordRenderCommand
override	command/rendercommands.hpp	/^    state::Report* makeReport() const override;$/;"	m	class:sword::command::SetSpecFloat
override	command/rendercommands.hpp	/^    state::Report* makeReport() const override;$/;"	m	class:sword::command::SetSpecInt
override	command/rendercommands.hpp	/^    void execute(Application* app) override;$/;"	m	class:sword::command::BindUboData
override	command/saveimage.hpp	/^    void execute(Application*) override;$/;"	m	class:sword::command::CopyAttachmentToUndoStack
override	command/saveimage.hpp	/^    void execute(Application*) override;$/;"	m	class:sword::command::SaveAttachmentToPng
override	command/saveimage.hpp	/^    void execute(Application*) override;$/;"	m	class:sword::command::SaveSwapToPng
override	command/shader.hpp	/^    state::Report* makeReport() const override;$/;"	m	class:sword::command::CompileShader
override	command/shader.hpp	/^    state::Report* makeReport() const override;$/;"	m	class:sword::command::CompileShaderCode
override	command/shader.hpp	/^    void execute(Application*) override;$/;"	m	class:sword::command::CompileShader
override	command/shader.hpp	/^    void execute(Application*) override;$/;"	m	class:sword::command::CompileShaderCode
override	command/transfer.hpp	/^    void execute(Application*) override;$/;"	m	class:sword::command::CopyAttachmentToDevice
override	command/vocab.hpp	/^    void execute(Application* app) override;$/;"	m	class:sword::command::AddVocab
override	command/vocab.hpp	/^    void execute(Application* app) override;$/;"	m	class:sword::command::PopVocab
override	command/vocab.hpp	/^    void execute(Application* app) override;$/;"	m	class:sword::command::SetVocab
override	command/vocab.hpp	/^    void execute(Application*) override;$/;"	m	class:sword::command::UpdateVocab
override	command/watcher.hpp	/^    state::Report* makeReport() const override;$/;"	m	class:sword::command::WatchFile
override	command/watcher.hpp	/^    void execute(Application*) override;$/;"	m	class:sword::command::WatchFile
override	state/descriptormanager.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::CreateFrameDescriptorSets
override	state/descriptormanager.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::InitFrameUbos
override	state/descriptormanager.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::UpdateFrameSamplers
override	state/descriptormanager.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::final
override	state/descriptormanager.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::CreateFrameDescriptorSets
override	state/descriptormanager.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::InitFrameUbos
override	state/descriptormanager.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::UpdateFrameSamplers
override	state/descriptorsetlayoutmanager.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::CreateDescriptorSetLayout
override	state/descriptorsetlayoutmanager.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::SetDescriptorCount
override	state/descriptorsetlayoutmanager.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::SetShaderStageEntry
override	state/descriptorsetlayoutmanager.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::SetStateType
override	state/descriptorsetlayoutmanager.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::final
override	state/descriptorsetlayoutmanager.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::CreateDescriptorSetLayout
override	state/descriptorsetlayoutmanager.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::SetDescriptorCount
override	state/descriptorsetlayoutmanager.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::SetShaderStageEntry
override	state/descriptorsetlayoutmanager.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::SetStateType
override	state/director.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::final
override	state/director.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::QuickSetup
override	state/painter.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::painter::Paint
override	state/painter.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::painter::ResizeBrush
override	state/painter.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::painter::Rotate
override	state/painter.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::painter::SaveAttachment
override	state/painter.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::painter::SaveSwap
override	state/painter.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::painter::Scale
override	state/painter.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::painter::Translate
override	state/painter.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::painter::final
override	state/painter.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::painter::ResizeBrush
override	state/painter.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::painter::Rotate
override	state/painter.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::painter::SaveAttachment
override	state/painter.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::painter::SaveSwap
override	state/painter.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::painter::Scale
override	state/painter.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::painter::Translate
override	state/pipelinemanager.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::CreateGraphicsPipeline
override	state/pipelinemanager.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::final
override	state/pipelinemanager.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::CreateGraphicsPipeline
override	state/pipelinemanager.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::final
override	state/rendermanager.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::CreateRenderLayer
override	state/rendermanager.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::RecordRenderCommand
override	state/rendermanager.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::Render
override	state/rendermanager.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::SaveSwapImage
override	state/rendermanager.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::final
override	state/rendermanager.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::CreateRenderLayer
override	state/rendermanager.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::OpenWindow
override	state/rendermanager.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::PrepareRenderFrames
override	state/rendermanager.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::RecordRenderCommand
override	state/rendermanager.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::Render
override	state/rendermanager.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::SaveSwapImage
override	state/renderpassmanager.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::CreateRenderPass
override	state/renderpassmanager.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::final
override	state/renderpassmanager.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::CreateRenderPass
override	state/shader.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::CompileShader
override	state/shader.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::LoadFragShaders
override	state/shader.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::LoadVertShaders
override	state/shader.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::PrintShader
override	state/shader.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::SetSpec
override	state/shader.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::WatchFile
override	state/shader.hpp	/^    void handleEvent(event::Event*) override;$/;"	m	class:sword::state::final
override	state/shader.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::CompileShader
override	state/shader.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::LoadFragShaders
override	state/shader.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::LoadVertShaders
override	state/shader.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::PrintShader
override	state/shader.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::SetSpec
override	state/shader.hpp	/^    void onEnterExt() override;$/;"	m	class:sword::state::WatchFile
owPool	state/rendermanager.hpp	/^    CommandPool<command::OpenWindow>& owPool;$/;"	m	class:sword::state::OpenWindow
pEventFunc	event/dispatcher.cpp	/^typedef void (EventDispatcher::*pEventFunc)(xcb_generic_event_t* event);$/;"	t	namespace:sword::event	file:
paint	state/painter.cpp	/^    paint = static_cast<uint8_t>(event::symbol::MouseButton::Left),$/;"	m	class:sword::state::painter::Input	file:
paint	state/painter.hpp	/^    Paint paint;$/;"	m	class:sword::state::painter::final
paint	state/painter.hpp	/^    enum class Op : Option {initBasic, paint, brushResize, saveAttachmentToPng};$/;"	m	class:sword::state::painter::final::Op
paintCmdId	state/painter.hpp	/^    int paintCmdId;$/;"	m	struct:sword::state::painter::PainterVars
painter	state/director.hpp	/^    enum class Op : Option {painter, pushRenderManager, printHierarchy, quickSetup, quickSetup2, quickSetup3};$/;"	m	class:sword::state::final::Op
painter	state/director.hpp	/^    painter::Painter painter;$/;"	m	class:sword::state::final
painter	state/painter.cpp	/^namespace painter$/;"	n	namespace:sword::state	file:
painter	state/painter.hpp	/^namespace painter$/;"	n	namespace:sword::state
painterVars	state/painter.hpp	/^    PainterVars painterVars;$/;"	m	class:sword::state::painter::final
parent	command/recordrendercommand.hpp	/^    RendererManager& parent;$/;"	m	class:sword::state::RecordRenderCommandState
path	command/watcher.hpp	/^    std::string path;$/;"	m	class:sword::command::WatchFile
path	event/event.hpp	/^    std::string path;$/;"	m	class:sword::event::symbol::File
physicalDevice	render/context.hpp	/^    vk::PhysicalDevice physicalDevice;$/;"	m	class:sword::render::Context
physicalDeviceFeatures	render/context.hpp	/^    vk::PhysicalDeviceFeatures physicalDeviceFeatures;$/;"	m	class:sword::render::Context
physicalDeviceMemoryProperties	render/context.hpp	/^    vk::PhysicalDeviceMemoryProperties physicalDeviceMemoryProperties;$/;"	m	class:sword::render::Context
physicalDeviceProperties	render/context.hpp	/^    vk::PhysicalDeviceProperties physicalDeviceProperties;$/;"	m	class:sword::render::Context
physicalDeviceProperties	render/types.hpp	/^    const vk::PhysicalDeviceProperties& physicalDeviceProperties;$/;"	m	struct:sword::render::BufferResources
pickQueueFamilyIndex	render/context.cpp	/^uint32_t Context::pickQueueFamilyIndex(vk::SurfaceKHR surface) const$/;"	f	class:sword::render::Context
pipeLayoutReports	state/pipelinemanager.hpp	/^    Reports<PipelineLayoutReport> pipeLayoutReports;$/;"	m	class:sword::state::final
pipeline	command/rendercommands.hpp	/^    std::string pipeline;$/;"	m	class:sword::command::CreateRenderLayer
pipeline	render/renderlayer.hpp	/^    const GraphicsPipeline& pipeline;$/;"	m	class:sword::render::RenderLayer
pipelineLayouts	render/renderer.hpp	/^    std::unordered_map<std::string, vk::PipelineLayout> pipelineLayouts;$/;"	m	class:sword::render::Renderer
pipelineManager	state/rendermanager.hpp	/^        descriptorManager, renderPassManager, pipelineManager, createRenderLayer, recordRenderCommand};$/;"	m	class:sword::state::final::Op
pipelineManager	state/rendermanager.hpp	/^    PipelineManager pipelineManager;$/;"	m	class:sword::state::final
pipelineName	state/report.hpp	/^    std::string pipelineName;$/;"	m	class:sword::state::RenderLayerReport
pivot	state/painter.hpp	/^    glm::mat4 pivot = glm::translate(glm::mat4(1.), glm::vec3{-0.5 * cMapX, -0.5 * cMapY, 0.0}); $/;"	m	struct:sword::state::painter::Matrices
pollEvents	event/dispatcher.cpp	/^void EventDispatcher::pollEvents()$/;"	f	class:sword::event::EventDispatcher
pollEvents	render/surface/window.cpp	/^xcb_generic_event_t* Window::pollEvents() const$/;"	f	class:sword::render::Window
pool	state/descriptormanager.hpp	/^    CommandPool<command::InitFrameUbos>& pool;$/;"	m	class:sword::state::InitFrameUbos
pool	state/descriptormanager.hpp	/^    CommandPool<command::UpdateFrameSamplers>& pool;$/;"	m	class:sword::state::UpdateFrameSamplers
pool	state/painter.hpp	/^    CommandPool<command::Render>& pool;$/;"	m	class:sword::state::painter::Paint
pool	state/painter.hpp	/^    CommandPool<command::SaveAttachmentToPng>& pool;$/;"	m	class:sword::state::painter::SaveAttachment
pool	state/painter.hpp	/^    CommandPool<command::SaveSwapToPng>& pool;$/;"	m	class:sword::state::painter::SaveSwap
pool	state/pipelinemanager.hpp	/^    CommandPool<command::CreateGraphicsPipeline>& pool;$/;"	m	class:sword::state::CreateGraphicsPipeline
pool	state/pipelinemanager.hpp	/^    CommandPool<command::CreatePipelineLayout>& pool;$/;"	m	class:sword::state::final
pool	state/rendermanager.hpp	/^    CommandPool<command::RecordRenderCommand>& pool;$/;"	m	class:sword::state::RecordRenderCommand
pool	state/rendermanager.hpp	/^    CommandPool<command::Render>& pool;$/;"	m	class:sword::state::Render
pool	state/rendermanager.hpp	/^    CommandPool<command::SaveSwapToPng>& pool;$/;"	m	class:sword::state::SaveSwapImage
pool	state/shader.hpp	/^    CommandPool<command::CompileShader>& pool;$/;"	m	class:sword::state::CompileShader
pool	state/shader.hpp	/^    CommandPool<command::WatchFile>& pool;$/;"	m	class:sword::state::WatchFile
pool	types/pool.hpp	/^    std::array<T, Size> pool;$/;"	m	class:sword::Pool
pop	types/stack.hpp	/^    void pop() {items.pop_back();}$/;"	f	class:sword::Stack
popBackBlock	render/resource.cpp	/^void Buffer::popBackBlock()$/;"	f	class:sword::render::Buffer
popBufferBlock	render/renderer.cpp	/^void Renderer::popBufferBlock()$/;"	f	class:sword::render::Renderer
popSelf	state/state.hpp	/^    void popSelf() { editStack.popState(); }$/;"	f	class:sword::state::LeafState
popState	application.cpp	/^void Application::popState()$/;"	f	class:sword::Application
popState	state/editstack.hpp	/^    void popState() { stack.push(nullptr); }$/;"	f	class:sword::state::EditStack
popTop	state/director.cpp	/^void Director::popTop()$/;"	f	class:sword::state::Director
popVocab	event/dispatcher.cpp	/^void EventDispatcher::popVocab()$/;"	f	class:sword::event::EventDispatcher
prepRenderFrames	state/rendermanager.hpp	/^    PrepareRenderFrames prepRenderFrames;$/;"	m	class:sword::state::final
prepRenderFrames	state/rendermanager.hpp	/^    enum class Op : Option {saveSwapImage, printReports, render, openWindow, prepRenderFrames, shaderManager, $/;"	m	class:sword::state::final::Op
prepareAsOffscreenPass	render/renderer.cpp	/^void Renderer::prepareAsOffscreenPass($/;"	f	class:sword::render::Renderer
prepareAsSwapchainPass	render/renderer.cpp	/^void Renderer::prepareAsSwapchainPass(RenderPass& rpSwap)$/;"	f	class:sword::render::Renderer
prepareRenderFrames	command/commandpools.hpp	/^    CommandPool<command::PrepareRenderFrames> prepareRenderFrames;$/;"	m	struct:sword::CommandPools
prepareRenderFrames	render/renderer.cpp	/^void Renderer::prepareRenderFrames(Window& window)$/;"	f	class:sword::render::Renderer
prepareRenderFrames	state/state.hpp	/^    const PrepareRenderFrames* prepareRenderFrames;$/;"	m	struct:sword::state::Register
presentMode	render/swapchain.hpp	/^	vk::PresentModeKHR presentMode;$/;"	m	class:sword::render::Swapchain
prfPool	state/rendermanager.hpp	/^    CommandPool<command::PrepareRenderFrames>& prfPool;$/;"	m	class:sword::state::PrepareRenderFrames
primaryCommandBuffers	render/command.hpp	/^    std::vector<std::unique_ptr<CommandBuffer>> primaryCommandBuffers;$/;"	m	class:sword::render::CommandPool
print	state/vocab.hpp	/^    void print()$/;"	f	class:sword::state::Vocab
print	types/stack.hpp	/^    void print() const {for (const auto& item : items) std::cout << item->getName() << std::endl;}$/;"	f	class:sword::Stack
printAll	types/pool.hpp	/^    void printAll() const $/;"	f	class:sword::Pool
printAvailableDevices	render/context.cpp	/^void Context::printAvailableDevices()$/;"	f	class:sword::render::Context
printDeviceExtensionProperties	render/context.cpp	/^void Context::printDeviceExtensionProperties()$/;"	f	class:sword::render::Context
printDeviceInfo	render/context.cpp	/^void Context::printDeviceInfo()$/;"	f	class:sword::render::Context
printDeviceMemoryHeapInfo	render/context.cpp	/^void Context::printDeviceMemoryHeapInfo()$/;"	f	class:sword::render::Context
printDeviceMemoryTypeInfo	render/context.cpp	/^void Context::printDeviceMemoryTypeInfo()$/;"	f	class:sword::render::Context
printDeviceQueueFamilyInfo	render/context.cpp	/^void Context::printDeviceQueueFamilyInfo()$/;"	f	class:sword::render::Context
printHierarchy	state/director.hpp	/^    enum class Op : Option {painter, pushRenderManager, printHierarchy, quickSetup, quickSetup2, quickSetup3};$/;"	m	class:sword::state::final::Op
printMask	state/state.cpp	/^void BranchState::printMask()$/;"	f	class:sword::state::BranchState
printReports	state/descriptormanager.cpp	/^void DescriptorManager::printReports()$/;"	f	class:sword::state::DescriptorManager
printReports	state/descriptormanager.hpp	/^    enum class Op : Option {createFrameDescriptorSets, printReports, descriptorSetLayoutMgr, initFrameUBOs, updateFrameSamplers};$/;"	m	class:sword::state::final::Op
printReports	state/descriptorsetlayoutmanager.cpp	/^void DescriptorSetLayoutManager::printReports()$/;"	f	class:sword::state::DescriptorSetLayoutManager
printReports	state/pipelinemanager.cpp	/^void PipelineManager::printReports()$/;"	f	class:sword::state::PipelineManager
printReports	state/rendermanager.cpp	/^void RenderManager::printReports() const$/;"	f	class:sword::state::RenderManager
printReports	state/rendermanager.hpp	/^    enum class Op : Option {saveSwapImage, printReports, render, openWindow, prepRenderFrames, shaderManager, $/;"	m	class:sword::state::final::Op
printReports	state/renderpassmanager.cpp	/^void RenderPassManager::printReports()$/;"	f	class:sword::state::RenderPassManager
printReports	state/shader.cpp	/^void ShaderManager::printReports()$/;"	f	class:sword::state::ShaderManager
printShader	state/shader.hpp	/^    PrintShader printShader;$/;"	m	class:sword::state::final
printShader	state/shader.hpp	/^    enum class Op : Option {watchFile, compileShader, printShader, loadFrag, loadVert, setSpecInt, setSpecFloat, printReports};$/;"	m	class:sword::state::final::Op
printStateHierarchy	state/director.cpp	/^void Director::printStateHierarchy()$/;"	f	class:sword::state::Director
printVocab	state/state.cpp	/^void State::printVocab()$/;"	f	class:sword::state::State
priorites	render/context.hpp	/^        priorites(queueCount, 1.0) \/\/all queues have a priority of one$/;"	f	struct:sword::render::QueueInfo
priorites	render/context.hpp	/^    std::vector<float> priorites;$/;"	m	struct:sword::render::QueueInfo
push	types/map.hpp	/^    void push(Element element)$/;"	f	class:sword::SmallMap
push	types/stack.hpp	/^    void push(T&& item) {items.push_back(std::forward<T>(item));}$/;"	f	class:sword::Stack
pushCmd	application.cpp	/^void Application::pushCmd(CmdPtr&& command)$/;"	f	class:sword::Application
pushCmd	state/state.cpp	/^void LeafState::pushCmd(CmdPtr&& cmd)$/;"	f	class:sword::state::LeafState
pushCmd	state/state.cpp	/^void State::pushCmd(CmdPtr&& cmd)$/;"	f	class:sword::state::State
pushCreateDescSetLayout	state/descriptorsetlayoutmanager.cpp	/^void DescriptorSetLayoutManager::pushCreateDescSetLayout()$/;"	f	class:sword::state::DescriptorSetLayoutManager
pushCreateRenderPass	state/renderpassmanager.cpp	/^void RenderPassManager::pushCreateRenderPass(RenderPassType type)$/;"	f	class:sword::state::RenderPassManager
pushRenderManager	state/director.cpp	/^void Director::pushRenderManager()$/;"	f	class:sword::state::Director
pushRenderManager	state/director.hpp	/^    enum class Op : Option {painter, pushRenderManager, printHierarchy, quickSetup, quickSetup2, quickSetup3};$/;"	m	class:sword::state::final::Op
pushState	application.cpp	/^void Application::pushState(state::State* state)$/;"	f	class:sword::Application
pushState	state/editstack.hpp	/^    void pushState(State* ptr) { stack.push(std::forward<State*>(ptr)); }$/;"	f	class:sword::state::EditStack
pushState	state/state.cpp	/^void BranchState::pushState(State* state)$/;"	f	class:sword::state::BranchState
push_back	state/vocab.hpp	/^    void push_back(std::string word) { words.push_back(word); }$/;"	f	class:sword::state::Vocab
pvPool	state/state.hpp	/^    CommandPool<command::PopVocab> pvPool;$/;"	m	class:sword::state::State
queueCount	render/context.hpp	/^    int queueCount;$/;"	m	struct:sword::render::QueueInfo
queueFamilies	render/context.hpp	/^    std::vector<vk::QueueFamilyProperties> queueFamilies;$/;"	m	class:sword::render::Context
quickSetup	state/director.cpp	/^void Director::quickSetup()$/;"	f	class:sword::state::Director
quickSetup	state/director.hpp	/^    enum class Op : Option {painter, pushRenderManager, printHierarchy, quickSetup, quickSetup2, quickSetup3};$/;"	m	class:sword::state::final::Op
quickSetup2	state/director.cpp	/^void Director::quickSetup2()$/;"	f	class:sword::state::Director
quickSetup2	state/director.hpp	/^    enum class Op : Option {painter, pushRenderManager, printHierarchy, quickSetup, quickSetup2, quickSetup3};$/;"	m	class:sword::state::final::Op
quickSetup3	state/director.cpp	/^void Director::quickSetup3()$/;"	f	class:sword::state::Director
quickState	state/director.hpp	/^    QuickSetup quickState;$/;"	m	class:sword::state::final
rasterizationState	render/pipeline.hpp	/^    vk::PipelineRasterizationStateCreateInfo rasterizationState;$/;"	m	class:sword::render::GraphicsPipeline
readEvent	event/dispatcher.cpp	/^void EventDispatcher::readEvent(std::ifstream& is)$/;"	f	class:sword::event::EventDispatcher
readEvents	application.cpp	/^void Application::readEvents(std::ifstream& is, int eventPops)$/;"	f	class:sword::Application
readEvents	event/dispatcher.cpp	/^void EventDispatcher::readEvents(std::ifstream& is, int eventPops)$/;"	f	class:sword::event::EventDispatcher
readlog	application.hpp	/^    std::string readlog;$/;"	m	class:sword::Application
receiveDescriptorSetLayoutReport	state/descriptormanager.cpp	/^void DescriptorManager::receiveDescriptorSetLayoutReport(const DescriptorSetLayoutReport* r)$/;"	f	class:sword::state::DescriptorManager
receiveDescriptorSetLayoutReport	state/rendermanager.cpp	/^void RenderManager::receiveDescriptorSetLayoutReport(const DescriptorSetLayoutReport* r)$/;"	f	class:sword::state::RenderManager
receiveGraphicsPipelineReport	state/rendermanager.cpp	/^void RenderManager::receiveGraphicsPipelineReport(const GraphicsPipelineReport* r)$/;"	f	class:sword::state::RenderManager
receiveReport	state/pipelinemanager.cpp	/^void PipelineManager::receiveReport(const Report* pReport)$/;"	f	class:sword::state::PipelineManager
receivedDSLReportCb	state/descriptormanager.hpp	/^    ReportCallbackFn<DescriptorSetLayoutReport> receivedDSLReportCb;$/;"	m	class:sword::state::final
recordEvent	application.cpp	/^void Application::recordEvent(event::Event* event, std::ofstream& os)$/;"	f	class:sword::Application
recordRenderCommand	command/commandpools.hpp	/^    CommandPool<command::RecordRenderCommand> recordRenderCommand;$/;"	m	struct:sword::CommandPools
recordRenderCommand	state/rendermanager.hpp	/^    RecordRenderCommand recordRenderCommand;$/;"	m	class:sword::state::final
recordRenderCommand	state/state.hpp	/^    const RecordRenderCommand* recordRenderCommand;$/;"	m	struct:sword::state::Register
recordRenderCommands	render/renderer.cpp	/^void Renderer::recordRenderCommands(uint32_t id, std::vector<uint32_t> fbIds)$/;"	f	class:sword::render::Renderer
recreate	render/pipeline.cpp	/^void GraphicsPipeline::recreate()$/;"	f	class:sword::render::GraphicsPipeline
recreateGraphicsPipeline	render/renderer.cpp	/^bool Renderer::recreateGraphicsPipeline(const std::string name)$/;"	f	class:sword::render::Renderer
recreateGraphicsPipeline	state/pipelinemanager.cpp	/^void PipelineManager::recreateGraphicsPipeline(GraphicsPipelineReport* report)$/;"	f	class:sword::state::PipelineManager
references	render/renderpass.hpp	/^    std::vector<vk::AttachmentReference> references;$/;"	m	class:sword::render::RenderPass
regionX	state/report.hpp	/^    int regionX;$/;"	m	class:sword::state::GraphicsPipelineReport
regionY	state/report.hpp	/^    int regionY;$/;"	m	class:sword::state::GraphicsPipelineReport
reload	render/shader.cpp	/^void Shader::reload(std::vector<uint32_t>&& code)$/;"	f	class:sword::render::Shader
remove	types/map.hpp	/^    void remove(T t)$/;"	f	class:sword::SmallMap
removeFragmentShader	render/renderer.hpp	/^    void removeFragmentShader(const std::string name) {fragmentShaders.erase(name);}$/;"	f	class:sword::render::Renderer
removeGraphicsPipeline	render/renderer.hpp	/^    void removeGraphicsPipeline(const std::string name) {graphicsPipelines.erase(name);}$/;"	f	class:sword::render::Renderer
removeVertexShader	render/renderer.hpp	/^    void removeVertexShader(const std::string name) {vertexShaders.erase(name);}$/;"	f	class:sword::render::Renderer
render	command/commandpools.hpp	/^    CommandPool<command::Render> render;$/;"	m	struct:sword::CommandPools
render	command/render.hpp	/^class render : public Command$/;"	c
render	command/transfer.hpp	/^namespace render { class CommandBuffer; };$/;"	n	namespace:sword
render	render/attachment.cpp	/^namespace render$/;"	n	namespace:sword	file:
render	render/attachment.hpp	/^namespace render$/;"	n	namespace:sword
render	render/command.cpp	/^namespace render$/;"	n	namespace:sword	file:
render	render/command.hpp	/^namespace render$/;"	n	namespace:sword
render	render/context.cpp	/^namespace render$/;"	n	namespace:sword	file:
render	render/context.hpp	/^namespace render$/;"	n	namespace:sword
render	render/dependencygraph.hpp	/^namespace render$/;"	n	namespace:sword
render	render/pipeline.cpp	/^namespace render$/;"	n	namespace:sword	file:
render	render/pipeline.hpp	/^namespace render$/;"	n	namespace:sword
render	render/renderer.cpp	/^namespace render$/;"	n	namespace:sword	file:
render	render/renderer.cpp	/^void Renderer::render(uint32_t cmdId, bool updateUbo)$/;"	f	class:sword::render::Renderer
render	render/renderer.hpp	/^namespace render$/;"	n	namespace:sword
render	render/renderframe.cpp	/^namespace render$/;"	n	namespace:sword	file:
render	render/renderframe.hpp	/^namespace render$/;"	n	namespace:sword
render	render/renderlayer.cpp	/^namespace render$/;"	n	namespace:sword	file:
render	render/renderlayer.hpp	/^namespace render$/;"	n	namespace:sword
render	render/renderpass.cpp	/^namespace render$/;"	n	namespace:sword	file:
render	render/renderpass.hpp	/^namespace render$/;"	n	namespace:sword
render	render/resource.cpp	/^namespace render$/;"	n	namespace:sword	file:
render	render/resource.hpp	/^namespace render$/;"	n	namespace:sword
render	render/shader.cpp	/^namespace render$/;"	n	namespace:sword	file:
render	render/shader.hpp	/^namespace render$/;"	n	namespace:sword
render	render/surface/window.cpp	/^namespace render$/;"	n	namespace:sword	file:
render	render/surface/window.hpp	/^namespace render$/;"	n	namespace:sword
render	render/swapchain.cpp	/^namespace render$/;"	n	namespace:sword	file:
render	render/swapchain.hpp	/^namespace render$/;"	n	namespace:sword
render	render/types.hpp	/^namespace render$/;"	n	namespace:sword
render	render/ubotypes.hpp	/^namespace render$/;"	n	namespace:sword
render	state/director.hpp	/^namespace render { class Window; }$/;"	n	namespace:sword
render	state/rendermanager.hpp	/^    Render render;$/;"	m	class:sword::state::final
render	state/rendermanager.hpp	/^    enum class Op : Option {saveSwapImage, printReports, render, openWindow, prepRenderFrames, shaderManager, $/;"	m	class:sword::state::final::Op
renderArea	render/pipeline.hpp	/^    vk::Rect2D renderArea;$/;"	m	class:sword::render::GraphicsPipeline
renderCmd	state/rendermanager.cpp	/^void RenderManager::renderCmd(int cmdIndex, bool updateUbo)$/;"	f	class:sword::state::RenderManager
renderCommandReports	state/rendermanager.hpp	/^    Reports<RenderCommandReport> renderCommandReports;$/;"	m	class:sword::state::final
renderLayers	command/rendercommands.hpp	/^    std::vector<uint32_t> renderLayers;$/;"	m	class:sword::command::RecordRenderCommand
renderLayers	render/renderframe.hpp	/^    std::vector<RenderLayer> renderLayers;$/;"	m	class:sword::render::RenderFrame
renderLayersReports	state/rendermanager.hpp	/^    Reports<RenderLayerReport> renderLayersReports;$/;"	m	class:sword::state::final
renderManager	state/director.hpp	/^    RenderManager renderManager;$/;"	m	class:sword::state::final
renderPass	render/pipeline.hpp	/^    const RenderPass& renderPass;$/;"	m	class:sword::render::GraphicsPipeline
renderPass	render/renderlayer.hpp	/^    const RenderPass& renderPass;$/;"	m	class:sword::render::RenderLayer
renderPassManager	state/rendermanager.hpp	/^        descriptorManager, renderPassManager, pipelineManager, createRenderLayer, recordRenderCommand};$/;"	m	class:sword::state::final::Op
renderPasses	render/renderer.hpp	/^    std::unordered_map<std::string, RenderPass> renderPasses;$/;"	m	class:sword::render::Renderer
renderPool	state/painter.hpp	/^    CommandPool<command::Render>& renderPool;$/;"	m	class:sword::state::painter::ResizeBrush
renderPool	state/painter.hpp	/^    CommandPool<command::Render>& renderPool;$/;"	m	class:sword::state::painter::Rotate
renderPool	state/painter.hpp	/^    CommandPool<command::Render>& renderPool;$/;"	m	class:sword::state::painter::Scale
renderPool	state/painter.hpp	/^    CommandPool<command::Render>& renderPool;$/;"	m	class:sword::state::painter::Translate
renderPool	state/rendermanager.hpp	/^    CommandPool<command::Render>& renderPool;$/;"	m	class:sword::state::final
renderTarget	render/renderlayer.hpp	/^    const Attachment& renderTarget;$/;"	m	class:sword::render::RenderLayer
renderer	application.hpp	/^    render::Renderer renderer;$/;"	m	class:sword::Application
renderpass	command/rendercommands.hpp	/^    std::string renderpass;$/;"	m	class:sword::command::CreateRenderLayer
renderpassInstances	command/recordrendercommand.hpp	/^    std::vector<uint32_t> renderpassInstances;$/;"	m	class:sword::command::RecordRenderCommand
renderpassName	state/report.hpp	/^    std::string renderpassName;$/;"	m	class:sword::state::RenderLayerReport
reportCallback	state/state.hpp	/^    const OwningReportCallbackFn reportCallback() const { return reportCallbackFn; }$/;"	f	class:sword::state::LeafState
reports	state/descriptorsetlayoutmanager.hpp	/^    Reports<DescriptorSetLayoutReport> reports;$/;"	m	class:sword::state::final
reports	state/pipelinemanager.hpp	/^    std::vector<const Report*> reports;$/;"	m	class:sword::state::final
reports	state/renderpassmanager.hpp	/^    Reports<RenderPassReport> reports;$/;"	m	class:sword::state::final
reports	state/shader.hpp	/^    ShaderReports& reports;$/;"	m	class:sword::state::SetSpec
reports	state/state.hpp	/^    std::vector<const Report*> reports;$/;"	m	class:sword::state::BranchState
request	types/pool.hpp	/^    Pointer request(Args... args)$/;"	f	class:sword::Pool
request	types/pool.hpp	/^    Pointer request(std::function<void(state::Report*)> reportCb, Args... args) \/\/requires IsCommand<T>$/;"	f	class:sword::Pool
requestBlock	render/resource.cpp	/^BufferBlock* Buffer::requestBlock(uint32_t blockSize)$/;"	f	class:sword::render::Buffer
requestCommandBuffer	render/command.cpp	/^CommandBuffer& CommandPool::requestCommandBuffer(uint32_t id, vk::CommandBufferLevel level)$/;"	f	class:sword::render::CommandPool
requestCommandBuffer	render/command.hpp	/^    CommandBuffer& requestCommandBuffer() { return *primaryCommandBuffers.at(0); };$/;"	f	class:sword::render::CommandPool
requestRenderBuffer	render/renderframe.cpp	/^CommandBuffer& RenderFrame::requestRenderBuffer(uint32_t bufferId)$/;"	f	class:sword::render::RenderFrame
requestSemaphore	render/renderframe.cpp	/^vk::Semaphore RenderFrame::requestSemaphore()$/;"	f	class:sword::render::RenderFrame
rerecordRenderCommand	state/rendermanager.cpp	/^void RenderManager::rerecordRenderCommand(RenderCommandReport* report)$/;"	f	class:sword::state::RenderManager
reset	command/command.hpp	/^    void reset() {inUse = false; }$/;"	f	class:sword::command::Command
reset	event/event.hpp	/^    void reset() {inUse = false; handled = false;}$/;"	f	class:sword::event::symbol::Event
reset	render/command.cpp	/^void CommandBuffer::reset()$/;"	f	class:sword::render::CommandBuffer
resetPool	render/command.cpp	/^void CommandPool::resetPool()$/;"	f	class:sword::render::CommandPool
resizeBrush	state/painter.cpp	/^    resizeBrush = static_cast<uint8_t>(event::symbol::Key::Alt),$/;"	m	class:sword::state::painter::Input	file:
resizeBrush	state/painter.hpp	/^    ResizeBrush resizeBrush;$/;"	m	class:sword::state::painter::final
reverse	command/saveimage.cpp	/^void CopyAttachmentToUndoStack::reverse(Application* app)$/;"	f	class:sword::command::CopyAttachmentToUndoStack
reverse	types/stack.hpp	/^    void reverse() { std::reverse(items.begin(), items.end()); }$/;"	f	class:sword::Stack
rg	state/state.hpp	/^    Register& rg;$/;"	m	struct:sword::state::StateArgs
ripFrom	types/region.hpp	/^    void ripFrom(void* dest, int size)$/;"	f	class:sword::Region
rotate	state/painter.cpp	/^    rotate = static_cast<uint8_t>(event::symbol::Key::Shift_L)$/;"	m	class:sword::state::painter::Input	file:
rotate	state/painter.hpp	/^    Rotate rotate;$/;"	m	class:sword::state::painter::final
rpassManager	state/rendermanager.hpp	/^    RenderPassManager rpassManager;$/;"	m	class:sword::state::final
rpassName	command/rendercommands.hpp	/^    std::string rpassName;$/;"	m	class:sword::command::CreateOffscreenRenderpass
rpassName	command/rendercommands.hpp	/^    std::string rpassName;$/;"	m	class:sword::command::CreateSwapchainRenderpass
rpiIndices	state/report.hpp	/^    std::vector<uint32_t> rpiIndices;$/;"	m	class:sword::state::RenderCommandReport
rrcPool	state/rendermanager.hpp	/^    CommandPool<command::RecordRenderCommand>& rrcPool;$/;"	m	class:sword::state::final
run	application.cpp	/^void Application::run(bool pollEvents)$/;"	f	class:sword::Application
run	event/filewatcher.cpp	/^void FileWatcher::run()$/;"	f	class:sword::event::FileWatcher
runCommandLineLoop	event/dispatcher.cpp	/^void EventDispatcher::runCommandLineLoop()$/;"	f	class:sword::event::EventDispatcher
runWindowInputLoop	event/dispatcher.cpp	/^void EventDispatcher::runWindowInputLoop()$/;"	f	class:sword::event::EventDispatcher
sampledImages	application.hpp	/^    std::vector<const render::Image*> sampledImages;$/;"	m	class:sword::Application
sampler	render/resource.hpp	/^    vk::Sampler sampler;$/;"	m	class:sword::render::final
saveAttachment	state/painter.hpp	/^    SaveAttachment saveAttachment;$/;"	m	class:sword::state::painter::final
saveAttachmentToPng	command/commandpools.hpp	/^    CommandPool<command::SaveAttachmentToPng> saveAttachmentToPng;$/;"	m	struct:sword::CommandPools
saveSwap	state/painter.hpp	/^    SaveSwap saveSwap;$/;"	m	class:sword::state::painter::final
saveSwapImage	state/rendermanager.hpp	/^    SaveSwapImage saveSwapImage;$/;"	m	class:sword::state::final
saveSwapImage	state/rendermanager.hpp	/^    enum class Op : Option {saveSwapImage, printReports, render, openWindow, prepRenderFrames, shaderManager, $/;"	m	class:sword::state::final::Op
saveSwapToPng	command/commandpools.hpp	/^    CommandPool<command::SaveSwapToPng> saveSwapToPng;$/;"	m	struct:sword::CommandPools
scale	state/painter.cpp	/^    scale = static_cast<uint8_t>(event::symbol::MouseButton::Right),$/;"	m	class:sword::state::painter::Input	file:
scale	state/painter.hpp	/^    Scale scale;$/;"	m	class:sword::state::painter::final
scaleRot	state/painter.hpp	/^    glm::mat4& scaleRot;$/;"	m	class:sword::state::painter::Rotate
scaleRot	state/painter.hpp	/^    glm::mat4& scaleRot;$/;"	m	class:sword::state::painter::Scale
scaleRotCache	state/painter.hpp	/^    glm::mat4 scaleRotCache;$/;"	m	class:sword::state::painter::Rotate
scaleRotCache	state/painter.hpp	/^    glm::mat4 scaleRotCache;$/;"	m	class:sword::state::painter::Scale
scissor	render/pipeline.hpp	/^    vk::Rect2D scissor;$/;"	m	class:sword::render::GraphicsPipeline
screen	render/surface/window.hpp	/^	xcb_screen_t* screen;$/;"	m	class:sword::render::Window
selfManaged	render/resource.hpp	/^    bool selfManaged = true;$/;"	m	class:sword::render::final
semaphore	render/renderframe.hpp	/^    vk::Semaphore semaphore;$/;"	m	class:sword::render::RenderFrame
serialize	event/event.hpp	/^    inline void serialize(std::ofstream& os) {$/;"	f	class:sword::event::symbol::CommandLine
serialize	event/event.hpp	/^   void serialize(std::ofstream& os) $/;"	f	class:sword::event::symbol::Abort
set	command/command.hpp	/^    template <typename... Args> void set(Args... args) {}$/;"	f	class:sword::command::Command
set	command/recordrendercommand.hpp	/^    inline void set(int index, std::vector<uint32_t> renderpassInstances)$/;"	f	class:sword::command::RecordRenderCommand
set	command/render.hpp	/^    void set() {}$/;"	f	class:render
set	command/rendercommands.hpp	/^    inline void set(int renderCommandId, bool updateUBO)$/;"	f	class:sword::command::Render
set	command/rendercommands.hpp	/^    inline void set(std::string n, std::vector<vk::DescriptorSetLayoutBinding> b) $/;"	f	class:sword::command::CreateDescriptorSetLayout
set	command/rendercommands.hpp	/^    inline void set(std::string name, ShaderType t, int first, int second) {$/;"	f	class:sword::command::SetSpecInt
set	command/rendercommands.hpp	/^    inline void set(std::vector<std::string> layouts) {layoutnames = layouts;}$/;"	f	class:sword::command::CreateFrameDescriptorSets
set	command/rendercommands.hpp	/^    void set( std::string n, std::vector<std::string> descSetLayoutNames)$/;"	f	class:sword::command::CreatePipelineLayout
set	command/rendercommands.hpp	/^    void set($/;"	f	class:sword::command::CreateGraphicsPipeline
set	command/rendercommands.hpp	/^    void set($/;"	f	class:sword::command::CreateRenderLayer
set	command/rendercommands.hpp	/^    void set(int index, std::vector<uint32_t> renderLayers)$/;"	f	class:sword::command::RecordRenderCommand
set	command/rendercommands.hpp	/^    void set(size_t size, uint32_t b) {this->size = size; binding = b;}$/;"	f	class:sword::command::InitFrameUbos
set	command/rendercommands.hpp	/^    void set(state::GraphicsPipelineReport* report)$/;"	f	class:sword::command::CreateGraphicsPipeline
set	command/rendercommands.hpp	/^    void set(state::RenderCommandReport* report)$/;"	f	class:sword::command::RecordRenderCommand
set	command/rendercommands.hpp	/^    void set(std::string name) {rpassName = name;}$/;"	f	class:sword::command::CreateSwapchainRenderpass
set	command/rendercommands.hpp	/^    void set(std::string name) {shaderName = name;}$/;"	f	class:sword::command::LoadFragShader
set	command/rendercommands.hpp	/^    void set(std::string name) {shaderName = name;}$/;"	f	class:sword::command::LoadVertShader
set	command/rendercommands.hpp	/^    void set(std::string name, ShaderType t, float first, float second) {$/;"	f	class:sword::command::SetSpecFloat
set	command/rendercommands.hpp	/^    void set(std::string name, int x, int y, vk::ImageUsageFlags usage)$/;"	f	class:sword::command::AddAttachment
set	command/rendercommands.hpp	/^    void set(std::string name, vk::AttachmentLoadOp op) {rpassName = name; loadOp = op;}$/;"	f	class:sword::command::CreateOffscreenRenderpass
set	command/rendercommands.hpp	/^    void set(std::vector<const vk::Image*> imagePtrs, uint32_t b) { this->imagePtrs = imagePtrs; binding = b;}$/;"	f	class:sword::command::UpdateFrameSamplers
set	command/rendercommands.hpp	/^    void set(std::vector<std::string> attachmentsNamesArg, uint32_t b) { this->attachmentNames = attachmentsNamesArg; binding = b;}$/;"	f	class:sword::command::UpdateFrameSamplers
set	command/rendercommands.hpp	/^    void set(void* address, int size) { this->address = address, this->size = size; }$/;"	f	class:sword::command::BindUboData
set	command/saveimage.hpp	/^    void set( const std::string_view attachmentName, const std::string_view fileName, int offset_x, int offset_y, int width, int height, bool fullPath = false ) $/;"	f	class:sword::command::SaveAttachmentToPng
set	command/saveimage.hpp	/^    void set( const std::string_view name) { fileName = name; }$/;"	f	class:sword::command::SaveSwapToPng
set	command/saveimage.hpp	/^    void set(Region* region, std::string_view attachmentName, int offset_x, int offset_y, int width, int height ) $/;"	f	class:sword::command::CopyAttachmentToUndoStack
set	command/shader.cpp	/^void CompileShader::set(const std::string_view rel_path, const std::string_view name, state::ShaderReport* report)$/;"	f	class:sword::command::CompileShader
set	command/shader.hpp	/^    void set(const std::string_view code, const std::string_view name, ShaderType type, state::ShaderReport* report = nullptr)$/;"	f	class:sword::command::CompileShaderCode
set	command/template.hpp	/^    void set() {}$/;"	f	class:sword::command::Name
set	command/transfer.hpp	/^    void set() {}$/;"	f	class:sword::command::CopyAttachmentToDevice
set	command/vocab.hpp	/^    void set(const state::Vocab* vPtr) { this->vocabPtr = vPtr; }$/;"	f	class:sword::command::AddVocab
set	command/vocab.hpp	/^    void set(const std::vector<std::string> v) { this->vocab = v; }$/;"	f	class:sword::command::SetVocab
set	command/watcher.hpp	/^    void set(std::string path) {this->path = path;}$/;"	f	class:sword::command::WatchFile
set	event/event.hpp	/^    template <typename... Args> void set(Args... args) {}$/;"	f	class:sword::event::symbol::Event
set	event/event.hpp	/^    void set(int wd, std::string path) { this->wd = wd; this->path = path; }$/;"	f	class:sword::event::symbol::File
set	event/event.hpp	/^    void set(int16_t x, int16_t y) {xPos = x; yPos = y;}$/;"	f	class:sword::event::symbol::final
set	event/event.hpp	/^    void set(int16_t x, int16_t y, symbol::Key key) {xPos = x; yPos = y; this->key = key;}$/;"	f	class:sword::event::symbol::final
set	event/event.hpp	/^    void set(int16_t x, int16_t y, symbol::MouseButton button) {xPos = x; yPos = y; this->button = button;}$/;"	f	class:sword::event::symbol::final
set	event/event.hpp	/^    void set(std::string input) { this->input = input;}$/;"	f	class:sword::event::symbol::CommandLine
set	event/event.hpp	/^   void set() {}$/;"	f	class:sword::event::symbol::Abort
set	state/vocab.hpp	/^    void set( std::vector<std::string> strings) { words = strings; }$/;"	f	class:sword::state::Vocab
setClass	render/surface/window.cpp	/^void Window::setClass()$/;"	f	class:sword::render::Window
setCommandBuffer	command/transfer.cpp	/^void CopyAttachmentToDevice::setCommandBuffer(render::CommandBuffer& buffer)$/;"	f	class:sword::command::CopyAttachmentToDevice
setDescriptorCount	state/descriptorsetlayoutmanager.hpp	/^    SetDescriptorCount setDescriptorCount;$/;"	m	class:sword::state::final
setDeviceExtensions	render/context.cpp	/^void Context::setDeviceExtensions(vk::DeviceCreateInfo& createInfo)$/;"	f	class:sword::render::Context
setEvents	render/surface/window.cpp	/^void Window::setEvents()$/;"	f	class:sword::render::Window
setFormat	render/swapchain.cpp	/^void Swapchain::setFormat()$/;"	f	class:sword::render::Swapchain
setHandled	event/event.hpp	/^    inline void setHandled() {handled = true;}$/;"	f	class:sword::event::symbol::Event
setImageCount	render/swapchain.cpp	/^void Swapchain::setImageCount(const uint32_t count)$/;"	f	class:sword::render::Swapchain
setImages	render/swapchain.cpp	/^void Swapchain::setImages()$/;"	f	class:sword::render::Swapchain
setInputMode	event/dispatcher.hpp	/^    inline void setInputMode(InputMode mode) {inputMode = mode;}$/;"	f	class:sword::event::EventDispatcher
setMaskPtr	state/vocab.hpp	/^    void setMaskPtr( OptionMask* ptr ) { mask = ptr; }$/;"	f	class:sword::state::Vocab
setName	render/surface/window.cpp	/^void Window::setName()$/;"	f	class:sword::render::Window
setPresentMode	render/swapchain.cpp	/^void Swapchain::setPresentMode()$/;"	f	class:sword::render::Swapchain
setQueueFamilyIndex	render/swapchain.cpp	/^void Swapchain::setQueueFamilyIndex()$/;"	f	class:sword::render::Swapchain
setShaderStageEntry	state/descriptorsetlayoutmanager.hpp	/^    SetShaderStageEntry setShaderStageEntry;$/;"	m	class:sword::state::final
setSpec	state/state.hpp	/^    const SetSpec* setSpec;$/;"	m	struct:sword::state::Register
setSpecFloat	command/commandpools.hpp	/^    CommandPool<command::SetSpecFloat> setSpecFloat;$/;"	m	struct:sword::CommandPools
setSpecFloat	state/report.hpp	/^    void setSpecFloat(int index, float val)$/;"	f	class:sword::state::final
setSpecFloat	state/shader.hpp	/^    SetSpec setSpecFloat;$/;"	m	class:sword::state::final
setSpecFloat	state/shader.hpp	/^    enum class Op : Option {watchFile, compileShader, printShader, loadFrag, loadVert, setSpecInt, setSpecFloat, printReports};$/;"	m	class:sword::state::final::Op
setSpecInt	command/commandpools.hpp	/^    CommandPool<command::SetSpecInt> setSpecInt;$/;"	m	struct:sword::CommandPools
setSpecInt	state/report.hpp	/^    void setSpecInt(int index, int val)$/;"	f	class:sword::state::final
setSpecInt	state/shader.hpp	/^    SetSpec setSpecInt;$/;"	m	class:sword::state::final
setSpecInt	state/shader.hpp	/^    enum class Op : Option {watchFile, compileShader, printShader, loadFrag, loadVert, setSpecInt, setSpecFloat, printReports};$/;"	m	class:sword::state::final::Op
setStateType	state/descriptorsetlayoutmanager.hpp	/^    SetStateType setStateType;$/;"	m	class:sword::state::final
setSuccessFn	command/command.hpp	/^    void setSuccessFn(SuccessFn fn) { successFn = fn; }$/;"	f	class:sword::command::Command
setSurfaceCapabilities	render/swapchain.cpp	/^void Swapchain::setSurfaceCapabilities()$/;"	f	class:sword::render::Swapchain
setSwapExtent	render/swapchain.cpp	/^void Swapchain::setSwapExtent()$/;"	f	class:sword::render::Swapchain
setType	state/renderpassmanager.cpp	/^void CreateRenderPass::setType(RenderPassType t)$/;"	f	class:sword::state::CreateRenderPass
setUsage	state/report.hpp	/^    void setUsage(ReportUsage usage) { this->usage = usage; }$/;"	f	class:sword::state::Report
setVocab	state/state.cpp	/^void State::setVocab(std::vector<std::string> strings)$/;"	f	class:sword::state::State
setVocabMask	state/state.hpp	/^    void setVocabMask(OptionMask* mask) { vocab.setMaskPtr(mask); }$/;"	f	class:sword::state::State
setVocabulary	event/dispatcher.cpp	/^void EventDispatcher::setVocabulary(std::vector<std::string> vocab)$/;"	f	class:sword::event::EventDispatcher
setWindowResolution	render/shader.cpp	/^void Shader::setWindowResolution(const uint32_t w, const uint32_t h)$/;"	f	class:sword::render::Shader
setupDebugMessenger	render/context.cpp	/^void Context::setupDebugMessenger()$/;"	f	class:sword::render::Context
setupDebugMessenger2	render/context.cpp	/^void Context::setupDebugMessenger2()$/;"	f	class:sword::render::Context
shader	state/shader.hpp	/^namespace shader$/;"	n	namespace:sword::state
shaderCode	render/shader.hpp	/^    std::vector<uint32_t> shaderCode;$/;"	m	class:sword::render::Shader
shaderManager	state/rendermanager.hpp	/^    ShaderManager shaderManager;$/;"	m	class:sword::state::final
shaderManager	state/rendermanager.hpp	/^    enum class Op : Option {saveSwapImage, printReports, render, openWindow, prepRenderFrames, shaderManager, $/;"	m	class:sword::state::final::Op
shaderName	command/rendercommands.hpp	/^    std::string shaderName;$/;"	m	class:sword::command::LoadFragShader
shaderName	command/rendercommands.hpp	/^    std::string shaderName;$/;"	m	class:sword::command::LoadVertShader
shaderName	command/rendercommands.hpp	/^    std::string shaderName;$/;"	m	class:sword::command::SetSpecFloat
shaderName	command/rendercommands.hpp	/^    std::string shaderName;$/;"	m	class:sword::command::SetSpecInt
shaderReports	state/shader.hpp	/^    ShaderReports shaderReports;$/;"	m	class:sword::state::final
shaderStageInfos	render/pipeline.hpp	/^    std::vector<vk::PipelineShaderStageCreateInfo> shaderStageInfos;$/;"	m	class:sword::render::GraphicsPipeline
shader_dir	state/shader.hpp	/^namespace shader_dir$/;"	n	namespace:sword::state
shaders	render/pipeline.hpp	/^    const std::vector<const Shader*> shaders;$/;"	m	class:sword::render::GraphicsPipeline
size	command/rendercommands.hpp	/^    int size;$/;"	m	class:sword::command::BindUboData
size	command/rendercommands.hpp	/^    size_t size;$/;"	m	class:sword::command::InitFrameUbos
size	render/renderer.hpp	/^    uint32_t size;$/;"	m	struct:sword::render::Ubo
size	render/resource.hpp	/^    unsigned long size;$/;"	m	class:sword::render::final
size	render/surface/window.hpp	/^	std::vector<int> size;$/;"	m	class:sword::render::Window
size	state/editstack.hpp	/^    size_t size() const { return stack.size(); }$/;"	f	class:sword::state::EditStack
size	types/map.hpp	/^    size_t size() const { return options.size(); }$/;"	f	class:sword::SmallMap
size	types/stack.hpp	/^    size_t size() const {return items.size();}$/;"	f	class:sword::Stack
specData	render/shader.hpp	/^    SpecData specData;$/;"	m	class:sword::render::Shader
specInfo	render/shader.hpp	/^    vk::SpecializationInfo specInfo;$/;"	m	class:sword::render::Shader
sr	state/director.hpp	/^    const state::Register& sr;$/;"	m	class:sword::state::final
sr	state/director.hpp	/^    state::Register& sr;$/;"	m	class:sword::state::QuickSetup
sr	state/painter.hpp	/^    const state::Register& sr;$/;"	m	class:sword::state::painter::final
src	state/shader.hpp	/^    constexpr const char* src = SWORD"\/src\/shaders";$/;"	m	namespace:sword::state::shader_dir
ssfPool	state/shader.hpp	/^    CommandPool<command::SetSpecFloat>& ssfPool;$/;"	m	class:sword::state::SetSpec
ssiPool	state/shader.hpp	/^    CommandPool<command::SetSpecInt>& ssiPool;$/;"	m	class:sword::state::SetSpec
stack	state/editstack.hpp	/^    ReverseStack<State*> stack;$/;"	m	class:sword::state::EditStack
stageInfo	render/shader.hpp	/^    vk::PipelineShaderStageCreateInfo stageInfo;$/;"	m	class:sword::render::Shader
start	util.hpp	/^void Timer::start()$/;"	f	class:sword::Timer
startTime	util.hpp	/^    std::chrono::time_point<std::chrono::high_resolution_clock> startTime, endTime;$/;"	m	class:sword::Timer
state	command/command.hpp	/^namespace state { class Report; class GraphicsPipelineReport; }$/;"	n	namespace:sword
state	command/recordrendercommand.hpp	/^namespace state$/;"	n	namespace:sword
state	command/shader.hpp	/^namespace state{ class ShaderReport; }$/;"	n	namespace:sword
state	command/vocab.hpp	/^namespace state { class Vocab; }$/;"	n	namespace:sword
state	event/event.hpp	/^namespace state { class Vocab; }$/;"	n	namespace:sword
state	state/descriptormanager.cpp	/^namespace state$/;"	n	namespace:sword	file:
state	state/descriptormanager.hpp	/^namespace state$/;"	n	namespace:sword
state	state/descriptorsetlayoutmanager.cpp	/^namespace state$/;"	n	namespace:sword	file:
state	state/descriptorsetlayoutmanager.hpp	/^namespace state$/;"	n	namespace:sword
state	state/director.cpp	/^namespace state$/;"	n	namespace:sword	file:
state	state/director.hpp	/^namespace state$/;"	n	namespace:sword
state	state/editstack.hpp	/^namespace state$/;"	n	namespace:sword
state	state/option.hpp	/^namespace state$/;"	n	namespace:sword
state	state/painter.cpp	/^namespace state$/;"	n	namespace:sword	file:
state	state/painter.hpp	/^namespace state$/;"	n	namespace:sword
state	state/pipelinemanager.cpp	/^namespace state$/;"	n	namespace:sword	file:
state	state/pipelinemanager.hpp	/^namespace state$/;"	n	namespace:sword
state	state/rendermanager.cpp	/^namespace state$/;"	n	namespace:sword	file:
state	state/rendermanager.hpp	/^namespace state$/;"	n	namespace:sword
state	state/renderpassmanager.cpp	/^namespace state$/;"	n	namespace:sword	file:
state	state/renderpassmanager.hpp	/^namespace state$/;"	n	namespace:sword
state	state/report.hpp	/^namespace state$/;"	n	namespace:sword
state	state/shader.cpp	/^namespace state$/;"	n	namespace:sword	file:
state	state/shader.hpp	/^namespace state$/;"	n	namespace:sword
state	state/state.cpp	/^namespace state$/;"	n	namespace:sword	file:
state	state/state.hpp	/^namespace state$/;"	n	namespace:sword
state	state/state.hpp	/^namespace sword { namespace state { class State; }; };$/;"	n	namespace:sword
state	state/statetypes.hpp	/^namespace state$/;"	n	namespace:sword
state	state/vocab.hpp	/^namespace state$/;"	n	namespace:sword
state	types/pool.hpp	/^namespace state { class Report; }$/;"	n	namespace:sword
stateEdits	application.hpp	/^    state::EditStack stateEdits;$/;"	m	class:sword::Application
stateRegister	application.hpp	/^    state::Register stateRegister;$/;"	m	class:sword::Application
stateStack	application.hpp	/^    StateStack stateStack;$/;"	m	class:sword::Application
stateStack	state/director.hpp	/^    const StateStack& stateStack;$/;"	m	class:sword::state::final
stop	event/filewatcher.cpp	/^void FileWatcher::stop()$/;"	f	class:sword::event::FileWatcher
string_type	state/report.hpp	/^    constexpr std::string_view string_type() const$/;"	f	class:sword::state::final
submit	render/command.cpp	/^vk::Semaphore CommandBuffer::submit($/;"	f	class:sword::render::CommandBuffer
submit	render/command.cpp	/^void CommandBuffer::submit()$/;"	f	class:sword::render::CommandBuffer
subpassDependencies	render/renderpass.hpp	/^    std::vector<vk::SubpassDependency> subpassDependencies;$/;"	m	class:sword::render::RenderPass
subpasses	render/renderpass.hpp	/^    std::vector<vk::SubpassDescription> subpasses;$/;"	m	class:sword::render::RenderPass
succeeded	command/command.hpp	/^    constexpr bool succeeded() {return success_status;}$/;"	f	class:sword::command::Command
success	command/command.hpp	/^    void success() {$/;"	f	class:sword::command::Command
surfCaps	render/swapchain.hpp	/^	vk::SurfaceCapabilitiesKHR surfCaps;$/;"	m	class:sword::render::Swapchain
surface	render/swapchain.hpp	/^	vk::SurfaceKHR surface;$/;"	m	class:sword::render::Swapchain
svPool	state/state.hpp	/^    CommandPool<command::SetVocab> svPool;$/;"	m	class:sword::state::LeafState
swapDim	application.hpp	/^    vk::Extent2D swapDim;;$/;"	m	class:sword::Application
swapchain	render/renderer.hpp	/^    std::unique_ptr<Swapchain> swapchain;$/;"	m	class:sword::render::Renderer
swapchain	render/swapchain.hpp	/^	vk::SwapchainKHR swapchain;$/;"	m	class:sword::render::Swapchain
swapchain	state/renderpassmanager.hpp	/^enum class RenderPassType : uint8_t {swapchain, offscreen};$/;"	m	class:sword::state::RenderPassType
swapchain	state/report.hpp	/^    enum class Type : uint8_t {swapchain, offscreen}; $/;"	m	class:sword::state::RenderPassReport::Type
swapchainAttachment	render/renderframe.hpp	/^    std::unique_ptr<Attachment> swapchainAttachment;$/;"	m	class:sword::render::RenderFrame
swapchainCreated	render/swapchain.hpp	/^	bool swapchainCreated = false;$/;"	m	class:sword::render::Swapchain
sword	application.cpp	/^namespace sword$/;"	n	file:
sword	application.hpp	/^namespace sword$/;"	n
sword	command/command.hpp	/^namespace sword$/;"	n
sword	command/commandpools.hpp	/^namespace sword$/;"	n
sword	command/recordrendercommand.hpp	/^namespace sword$/;"	n
sword	command/rendercommands.cpp	/^namespace sword$/;"	n	file:
sword	command/rendercommands.hpp	/^namespace sword$/;"	n
sword	command/saveimage.cpp	/^namespace sword$/;"	n	file:
sword	command/saveimage.hpp	/^namespace sword$/;"	n
sword	command/shader.cpp	/^namespace sword$/;"	n	file:
sword	command/shader.hpp	/^namespace sword$/;"	n
sword	command/template.hpp	/^namespace sword$/;"	n
sword	command/transfer.cpp	/^namespace sword$/;"	n	file:
sword	command/transfer.hpp	/^namespace sword$/;"	n
sword	command/vocab.cpp	/^namespace sword$/;"	n	file:
sword	command/vocab.hpp	/^namespace sword$/;"	n
sword	command/watcher.cpp	/^namespace sword$/;"	n	file:
sword	command/watcher.hpp	/^namespace sword$/;"	n
sword	event/dispatcher.cpp	/^namespace sword$/;"	n	file:
sword	event/dispatcher.hpp	/^namespace sword$/;"	n
sword	event/event.cpp	/^namespace sword$/;"	n	file:
sword	event/event.hpp	/^namespace sword$/;"	n
sword	event/filewatcher.cpp	/^namespace sword$/;"	n	file:
sword	event/filewatcher.hpp	/^namespace sword$/;"	n
sword	event/types.hpp	/^namespace sword$/;"	n
sword	event/watcher.hpp	/^namespace sword$/;"	n
sword	render/attachment.cpp	/^namespace sword$/;"	n	file:
sword	render/attachment.hpp	/^namespace sword$/;"	n
sword	render/command.cpp	/^namespace sword$/;"	n	file:
sword	render/command.hpp	/^namespace sword$/;"	n
sword	render/context.cpp	/^namespace sword$/;"	n	file:
sword	render/context.hpp	/^namespace sword$/;"	n
sword	render/dependencygraph.hpp	/^namespace sword$/;"	n
sword	render/pipeline.cpp	/^namespace sword$/;"	n	file:
sword	render/pipeline.hpp	/^namespace sword$/;"	n
sword	render/renderer.cpp	/^namespace sword$/;"	n	file:
sword	render/renderer.hpp	/^namespace sword$/;"	n
sword	render/renderframe.cpp	/^namespace sword$/;"	n	file:
sword	render/renderframe.hpp	/^namespace sword$/;"	n
sword	render/renderlayer.cpp	/^namespace sword$/;"	n	file:
sword	render/renderlayer.hpp	/^namespace sword$/;"	n
sword	render/renderpass.cpp	/^namespace sword$/;"	n	file:
sword	render/renderpass.hpp	/^namespace sword$/;"	n
sword	render/resource.cpp	/^namespace sword$/;"	n	file:
sword	render/resource.hpp	/^namespace sword$/;"	n
sword	render/shader.cpp	/^namespace sword$/;"	n	file:
sword	render/shader.hpp	/^namespace sword$/;"	n
sword	render/surface/window.cpp	/^namespace sword$/;"	n	file:
sword	render/surface/window.hpp	/^namespace sword$/;"	n
sword	render/swapchain.cpp	/^namespace sword$/;"	n	file:
sword	render/swapchain.hpp	/^namespace sword$/;"	n
sword	render/types.hpp	/^namespace sword$/;"	n
sword	render/ubotypes.hpp	/^namespace sword$/;"	n
sword	state/descriptormanager.cpp	/^namespace sword$/;"	n	file:
sword	state/descriptormanager.hpp	/^namespace sword$/;"	n
sword	state/descriptorsetlayoutmanager.cpp	/^namespace sword $/;"	n	file:
sword	state/descriptorsetlayoutmanager.hpp	/^namespace sword$/;"	n
sword	state/director.cpp	/^namespace sword$/;"	n	file:
sword	state/director.hpp	/^namespace sword$/;"	n
sword	state/editstack.hpp	/^namespace sword$/;"	n
sword	state/option.hpp	/^namespace sword$/;"	n
sword	state/painter.cpp	/^namespace sword$/;"	n	file:
sword	state/painter.hpp	/^namespace sword$/;"	n
sword	state/pipelinemanager.cpp	/^namespace sword$/;"	n	file:
sword	state/pipelinemanager.hpp	/^namespace sword$/;"	n
sword	state/rendermanager.cpp	/^namespace sword$/;"	n	file:
sword	state/rendermanager.hpp	/^namespace sword$/;"	n
sword	state/renderpassmanager.cpp	/^namespace sword$/;"	n	file:
sword	state/renderpassmanager.hpp	/^namespace sword$/;"	n
sword	state/report.hpp	/^namespace sword$/;"	n
sword	state/shader.cpp	/^namespace sword$/;"	n	file:
sword	state/shader.hpp	/^namespace sword$/;"	n
sword	state/state.cpp	/^namespace sword$/;"	n	file:
sword	state/state.hpp	/^namespace sword { namespace state { class State; }; };$/;"	n
sword	state/state.hpp	/^namespace sword$/;"	n
sword	state/statetypes.hpp	/^namespace sword$/;"	n
sword	state/vocab.hpp	/^namespace sword$/;"	n
sword	types/heap.hpp	/^namespace sword$/;"	n
sword	types/map.hpp	/^namespace sword$/;"	n
sword	types/pool.cpp	/^namespace sword$/;"	n	file:
sword	types/pool.hpp	/^namespace sword$/;"	n
sword	types/region.hpp	/^namespace sword$/;"	n
sword	types/spirv.hpp	/^namespace sword$/;"	n
sword	types/stack.hpp	/^namespace sword$/;"	n
sword	util.hpp	/^namespace sword$/;"	n
sword	util/enum.hpp	/^namespace sword$/;"	n
sword	util/file.cpp	/^namespace sword$/;"	n	file:
sword	util/file.hpp	/^namespace sword$/;"	n
sword	util/outformat.hpp	/^namespace sword$/;"	n
sword	util/stringutil.hpp	/^namespace sword$/;"	n
symbol	event/event.hpp	/^namespace symbol$/;"	n	namespace:sword::event
toCanvasSpace	state/painter.hpp	/^    glm::mat4 toCanvasSpace = glm::scale(glm::mat4(1.), glm::vec3(cMapX, cMapY, 1.0)); $/;"	m	struct:sword::state::painter::Matrices
toCommandLine	state/state.hpp	/^constexpr event::CommandLine* toCommandLine(event::Event* event) { return static_cast<event::CommandLine*>(event);}$/;"	f	namespace:sword::state
toRel	util/file.cpp	/^const std::string toRel(const std::filesystem::path p, const std::filesystem::path root, bool inc_ext)$/;"	f	namespace:sword
toSpv	util/file.cpp	/^const std::string toSpv(const std::string_view path, bool has_ext)$/;"	f	namespace:sword
toWindowEvent	state/painter.cpp	/^constexpr event::Window* toWindowEvent(event::Event* event) { return static_cast<event::Window*>(event); }$/;"	f	class:sword::state::painter::Input	file:
top	types/stack.hpp	/^    T top() const {return items.back();}$/;"	f	class:sword::Stack
topMask	state/state.hpp	/^    OptionMask topMask;$/;"	m	class:sword::state::BranchState
topPtr	types/stack.hpp	/^    auto topPtr() const {return items.back().get();}$/;"	f	class:sword::Stack
tranlatePrevious	state/painter.hpp	/^    glm::mat4 tranlatePrevious;$/;"	m	class:sword::state::painter::Translate
transferQueueInfo	render/context.hpp	/^    std::optional<QueueInfo> transferQueueInfo;$/;"	m	class:sword::render::Context
translate	state/painter.cpp	/^    translate = static_cast<uint8_t>(event::symbol::MouseButton::Middle),$/;"	m	class:sword::state::painter::Input	file:
translate	state/painter.hpp	/^    Translate translate;$/;"	m	class:sword::state::painter::final
translate	state/painter.hpp	/^    glm::mat4& translate;$/;"	m	class:sword::state::painter::Translate
type	command/rendercommands.hpp	/^    ShaderType type;$/;"	m	class:sword::command::SetSpecFloat
type	command/rendercommands.hpp	/^    ShaderType type;$/;"	m	class:sword::command::SetSpecInt
type	command/shader.hpp	/^    ShaderType type;$/;"	m	class:sword::command::CompileShader
type	command/shader.hpp	/^    ShaderType type;$/;"	m	class:sword::command::CompileShaderCode
type	state/renderpassmanager.hpp	/^    RenderPassType type;$/;"	m	class:sword::state::CreateRenderPass
type	state/report.hpp	/^    ShaderType type;$/;"	m	class:sword::state::final
type	state/report.hpp	/^    Type type;$/;"	m	class:sword::state::DescriptorSetReport
type	state/report.hpp	/^    Type type;$/;"	m	class:sword::state::RenderPassReport
type	state/shader.hpp	/^    shader::SpecType type;$/;"	m	class:sword::state::SetSpec
typeToString	state/report.hpp	/^    inline std::string typeToString() const$/;"	f	class:sword::state::RenderPassReport
ubos	render/renderer.hpp	/^    std::vector<Ubo> ubos;$/;"	m	class:sword::render::Renderer
undoStack	command/saveimage.hpp	/^    Region* undoStack;$/;"	m	class:sword::command::CopyAttachmentToUndoStack
unmap	render/resource.cpp	/^void Buffer::unmap()$/;"	f	class:sword::render::Buffer
unserialize	event/event.hpp	/^    inline void unserialize(std::ifstream& is) {$/;"	f	class:sword::event::symbol::CommandLine
unserializeCategory	event/event.hpp	/^    inline static Category unserializeCategory(std::ifstream& is)$/;"	f	class:sword::event::symbol::Event
updateActiveVocab	state/state.cpp	/^void BranchState::updateActiveVocab()$/;"	f	class:sword::state::BranchState
updateFrameDescriptorBuffer	render/renderer.cpp	/^void Renderer::updateFrameDescriptorBuffer(uint32_t frameIndex, uint32_t uboIndex)$/;"	f	class:sword::render::Renderer
updateFrameSamplers	command/commandpools.hpp	/^    CommandPool<command::UpdateFrameSamplers> updateFrameSamplers;$/;"	m	struct:sword::CommandPools
updateFrameSamplers	render/renderer.cpp	/^void Renderer::updateFrameSamplers(const std::vector<const Image*>& images, uint32_t binding)$/;"	f	class:sword::render::Renderer
updateFrameSamplers	render/renderer.cpp	/^void Renderer::updateFrameSamplers(const std::vector<std::string>& attachmentNames, uint32_t binding)$/;"	f	class:sword::render::Renderer
updateFrameSamplers	render/renderer.cpp	/^void Renderer::updateFrameSamplers(const vk::ImageView* view, const vk::Sampler* sampler, uint32_t binding)$/;"	f	class:sword::render::Renderer
updateFrameSamplers	state/descriptormanager.hpp	/^    UpdateFrameSamplers updateFrameSamplers;$/;"	m	class:sword::state::final
updateVocab	event/dispatcher.cpp	/^void EventDispatcher::updateVocab()$/;"	f	class:sword::event::EventDispatcher
updateVocab	state/state.cpp	/^void State::updateVocab()$/;"	f	class:sword::state::State
updateXform	state/painter.cpp	/^void updateXform(glm::mat4& xform, const Matrices& mats)$/;"	f	class:sword::state::painter::Input	file:
usage	command/rendercommands.hpp	/^    vk::ImageUsageFlags usage;$/;"	m	class:sword::command::AddAttachment
usageFlags	render/resource.cpp	/^	usageFlags(usageFlags)$/;"	f	namespace:sword::render
usageFlags	render/resource.hpp	/^    vk::ImageUsageFlags usageFlags;$/;"	m	class:sword::render::final
usageFlags	render/swapchain.hpp	/^	vk::ImageUsageFlags usageFlags;$/;"	m	class:sword::render::Swapchain
usageFlags	state/report.hpp	/^    vk::ImageUsageFlags usageFlags;$/;"	m	class:sword::state::AttachmentReport
util	util/stringutil.hpp	/^namespace util$/;"	n	namespace:sword
uvPool	state/state.hpp	/^    CommandPool<command::UpdateVocab> uvPool;$/;"	m	class:sword::state::State
validationLayersOn	render/context.hpp	/^    bool validationLayersOn; $/;"	m	class:sword::render::Context
valueAt	types/map.hpp	/^    T valueAt(int i) const { return options.at(i).second; }$/;"	f	class:sword::SmallMap
values	render/surface/window.hpp	/^	uint32_t values[2];$/;"	m	class:sword::render::Window
vars	state/painter.hpp	/^    const PainterVars& vars;$/;"	m	class:sword::state::painter::Paint
vars	state/painter.hpp	/^    const PainterVars& vars;$/;"	m	class:sword::state::painter::ResizeBrush
vars	state/painter.hpp	/^    const PainterVars& vars;$/;"	m	class:sword::state::painter::Rotate
vars	state/painter.hpp	/^    const PainterVars& vars;$/;"	m	class:sword::state::painter::Scale
vars	state/painter.hpp	/^    const PainterVars& vars;$/;"	m	class:sword::state::painter::Translate
vert	render/renderer.hpp	/^enum class ShaderType {vert, frag};$/;"	m	class:sword::render::ShaderType
vert	state/shader.hpp	/^    constexpr const char* vert = SWORD"\/src\/shaders\/vertex";$/;"	m	namespace:sword::state::shader_dir
vertShaderAt	render/renderer.cpp	/^VertShader& Renderer::vertShaderAt(const std::string name)$/;"	f	class:sword::render::Renderer
vert_dir	state/shader.hpp	/^    static constexpr const char* vert_dir = shader_dir::vert;$/;"	m	class:sword::state::LoadVertShaders
vertexInputState	render/pipeline.hpp	/^    vk::PipelineVertexInputStateCreateInfo vertexInputState;$/;"	m	class:sword::render::GraphicsPipeline
vertexShaders	render/renderer.hpp	/^    std::unordered_map<std::string, VertShader> vertexShaders;$/;"	m	class:sword::render::Renderer
view	render/resource.hpp	/^    vk::ImageView view;$/;"	m	class:sword::render::final
viewCmdId	state/painter.hpp	/^    int viewCmdId;$/;"	m	struct:sword::state::painter::PainterVars
viewport	render/pipeline.hpp	/^    vk::Viewport viewport;$/;"	m	class:sword::render::GraphicsPipeline
viewportState	render/pipeline.hpp	/^    vk::PipelineViewportStateCreateInfo viewportState;$/;"	m	class:sword::render::GraphicsPipeline
vocab	command/vocab.hpp	/^    std::vector<std::string> vocab;$/;"	m	class:sword::command::SetVocab
vocab	state/state.hpp	/^    Vocab vocab;$/;"	m	class:sword::state::State
vocabPtr	command/vocab.hpp	/^    const state::Vocab* vocabPtr;$/;"	m	class:sword::command::AddVocab
vocabPtrs	event/dispatcher.hpp	/^    inline static std::vector<const state::Vocab*> vocabPtrs;$/;"	m	class:sword::event::EventDispatcher
waitForEvent	render/surface/window.cpp	/^xcb_generic_event_t* Window::waitForEvent() const$/;"	f	class:sword::render::Window
waitForFence	render/command.cpp	/^void CommandBuffer::waitForFence() const$/;"	f	class:sword::render::CommandBuffer
waitOnCommandBuffer	render/command.cpp	/^void waitOnCommandBuffer(CommandBuffer& buffer, const vk::Device& device)$/;"	f	namespace:sword::render
watchFile	command/commandpools.hpp	/^    CommandPool<command::WatchFile> watchFile;$/;"	m	struct:sword::CommandPools
watchFile	state/shader.hpp	/^    WatchFile watchFile;$/;"	m	class:sword::state::final
watchFile	state/shader.hpp	/^    enum class Op : Option {watchFile, compileShader, printShader, loadFrag, loadVert, setSpecInt, setSpecFloat, printReports};$/;"	m	class:sword::state::final::Op
watches	event/filewatcher.hpp	/^    std::vector<WatchTicket> watches;$/;"	m	class:sword::event::FileWatcher
wd	event/event.hpp	/^    int wd;$/;"	m	class:sword::event::symbol::File
wd	event/filewatcher.hpp	/^    int wd;$/;"	m	struct:sword::event::WatchTicket
width	render/renderframe.hpp	/^    uint32_t width;$/;"	m	class:sword::render::RenderFrame
width	render/surface/window.hpp	/^    uint16_t width, height;$/;"	m	class:sword::render::Window
width	state/report.hpp	/^    const int width, height;$/;"	m	class:sword::state::AttachmentReport
window	application.hpp	/^    render::Window window;$/;"	m	class:sword::Application
window	event/dispatcher.hpp	/^    const render::Window& window;$/;"	m	class:sword::event::EventDispatcher
window	render/surface/window.hpp	/^	xcb_window_t window;$/;"	m	class:sword::render::Window
window	render/swapchain.hpp	/^	const Window& window;$/;"	m	class:sword::render::Swapchain
windowInput	event/dispatcher.hpp	/^    WindowInput windowInput;$/;"	m	class:sword::event::EventDispatcher
wmDeleteWin	render/surface/window.hpp	/^	xcb_atom_t wmDeleteWin;$/;"	m	class:sword::render::Window
wmProtocols	render/surface/window.hpp	/^	xcb_atom_t wmProtocols;$/;"	m	class:sword::render::Window
words	state/vocab.hpp	/^    std::vector<std::string> words;$/;"	m	class:sword::state::Vocab
xform	state/painter.hpp	/^    glm::mat4& xform;$/;"	m	class:sword::state::painter::Rotate
xform	state/painter.hpp	/^    glm::mat4& xform;$/;"	m	class:sword::state::painter::Scale
xform	state/painter.hpp	/^    glm::mat4& xform;$/;"	m	class:sword::state::painter::Translate
~Attachment	render/attachment.cpp	/^Attachment::~Attachment()$/;"	f	class:sword::render::Attachment
~Buffer	render/resource.cpp	/^Buffer::~Buffer()$/;"	f	class:sword::render::Buffer
~Context	render/context.cpp	/^Context::~Context()$/;"	f	class:sword::render::Context
~EventDispatcher	event/dispatcher.cpp	/^EventDispatcher::~EventDispatcher()$/;"	f	class:sword::event::EventDispatcher
~GraphicsPipeline	render/pipeline.cpp	/^GraphicsPipeline::~GraphicsPipeline()$/;"	f	class:sword::render::GraphicsPipeline
~Image	render/resource.cpp	/^Image::~Image()$/;"	f	class:sword::render::Image
~Region	types/region.hpp	/^    ~Region()$/;"	f	class:sword::Region
~RenderFrame	render/renderframe.cpp	/^RenderFrame::~RenderFrame()$/;"	f	class:sword::render::RenderFrame
~RenderLayer	render/renderlayer.cpp	/^RenderLayer::~RenderLayer()$/;"	f	class:sword::render::RenderLayer
~RenderPass	render/renderpass.cpp	/^RenderPass::~RenderPass()$/;"	f	class:sword::render::RenderPass
~Renderer	render/renderer.cpp	/^Renderer::~Renderer()$/;"	f	class:sword::render::Renderer
~Shader	render/shader.cpp	/^Shader::~Shader()$/;"	f	class:sword::render::Shader
~Swapchain	render/swapchain.cpp	/^Swapchain::~Swapchain()$/;"	f	class:sword::render::Swapchain
~Window	render/surface/window.cpp	/^Window::~Window()$/;"	f	class:sword::render::Window
